# GitHub-specific checks configuration
# Maps to Check model structure in checks/models.py
# Updated to use framework_id and control_id from CSV data for better performance

checks:
  - id: 1001
    connection_id: 1
    name: "github_main_branch_protected"
    description: "Verify that the main branch in GitHub repository has protection enabled"
    framework_id: 3  # NIST 800-171 rev2 Catalog
    framework_name: "NIST 800-171 rev2 Catalog"
    control_id: 1240  # CM-3-4-3 (Configuration Change Control)
    control_name: "CM-3-4-3"
    resource_type: "GithubResource"
    field_path: "repository_data.branches"
    resource_type: "GithubResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if the main branch (or master branch) is protected
        if not isinstance(fetched_value, list):
            result = False
        else:
            result = False  # Default to False if main branch not found
            main_branch_names = ['main', 'master', 'production', 'prod']  # Common main branch names
            
            for branch in fetched_value:
                branch_name = None
                is_protected = False
                
                if isinstance(branch, dict):
                    branch_name = branch.get('name', '')
                    is_protected = branch.get('protected', False)
                else:
                    # Handle Pydantic models
                    branch_name = getattr(branch, 'name', '')
                    is_protected = getattr(branch, 'protected', False)
                
                # Check if this is a main branch
                if branch_name in main_branch_names:
                    result = is_protected
                    break  # Found main branch, stop looking
    expected_value: null
    tags: ["security", "github", "branch_protection", "main_branch"]
    severity: "high"
    category: "access_control"

  - id: 1002
    connection_id: 1
    name: "github_repository_private"
    description: "Verify that GitHub repository is private"
    framework_id: 3  # NIST 800-171 rev2 Catalog
    framework_name: "NIST 800-171 rev2 Catalog"
    control_id: 1217  # AC-3-1-18 (Access Control for Mobile Devices)
    control_name: "AC-3-1-18"
    resource_type: "GithubResource"
    field_path: "repository_data.basic_info.private"
    resource_type: "GithubResource"
    operation:
      name: "EQUAL"
    expected_value: true
    tags: ["security", "github", "visibility"]
    severity: "medium"
    category: "access_control"

  - id: 1003
    connection_id: 1
    name: "github_minimum_branch_count"
    description: "Verify that GitHub repository has at least 3 branches"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 287  # CM-8 (System Component Inventory)
    control_name: "CM-8"
    resource_type: "GithubResource"
    field_path: "len(repository_data.branches)"
    resource_type: "GithubResource"
    operation:
      name: "GREATER_THAN_OR_EQUAL"
    expected_value: 3
    tags: ["development", "github", "branch_management"]
    severity: "low"
    category: "development_practices"

  # NIST 800-171 Rev 2 - Additional Security Controls
  - id: 1004
    connection_id: 1
    name: "github_advanced_security_enabled"
    description: "Verify that GitHub Advanced Security is enabled"
    framework_id: 3  # NIST 800-171 rev2 Catalog
    framework_name: "NIST 800-171 rev2 Catalog"
    control_id: 1303  # SI-3-14-1 (Flaw Remediation)
    control_name: "SI-3-14-1"
    resource_type: "GithubResource"
    field_path: "security_data.security_analysis.advanced_security_enabled"
    resource_type: "GithubResource"
    operation:
      name: "EQUAL"
    expected_value: true
    tags: ["security", "github", "advanced_security"]
    severity: "high"
    category: "security_assessment"

  - id: 1005
    connection_id: 1
    name: "github_secret_scanning_enabled"
    description: "Verify that secret scanning is enabled to protect authentication info"
    framework_id: 3  # NIST 800-171 rev2 Catalog
    framework_name: "NIST 800-171 rev2 Catalog"
    control_id: 1255  # IA-3-5-9 (Password Management)
    control_name: "IA-3-5-9"
    resource_type: "GithubResource"
    field_path: "security_data.security_analysis.secret_scanning_enabled"
    resource_type: "GithubResource"
    operation:
      name: "EQUAL"
    expected_value: true
    tags: ["security", "github", "secret_scanning"]
    severity: "high"
    category: "identity_authentication"

  - id: 1006
    connection_id: 1
    name: "github_push_protection_enabled"
    description: "Verify that push protection is enabled to prevent secret leaks"
    framework_id: 3  # NIST 800-171 rev2 Catalog
    framework_name: "NIST 800-171 rev2 Catalog"
    control_id: 1255  # IA-3-5-9 (Password Management)
    control_name: "IA-3-5-9"
    resource_type: "GithubResource"
    field_path: "security_data.security_analysis.push_protection_enabled"
    resource_type: "GithubResource"
    operation:
      name: "EQUAL"
    expected_value: true
    tags: ["security", "github", "push_protection"]
    severity: "high"
    category: "identity_authentication"

  - id: 1007
    connection_id: 1
    name: "github_dependency_review_enabled"
    description: "Verify that dependency review is enabled for vulnerability management"
    framework_id: 3  # NIST 800-171 rev2 Catalog
    framework_name: "NIST 800-171 rev2 Catalog"
    control_id: 1303  # SI-3-14-1 (Flaw Remediation)
    control_name: "SI-3-14-1"
    resource_type: "GithubResource"
    field_path: "security_data.security_analysis.dependency_review_enabled"
    resource_type: "GithubResource"
    operation:
      name: "EQUAL"
    expected_value: true
    tags: ["security", "github", "dependency_review"]
    severity: "medium"
    category: "security_assessment"

  - id: 1008
    connection_id: 1
    name: "github_no_dependabot_alerts"
    description: "Verify that there are no unresolved Dependabot security alerts"
    framework_id: 3  # NIST 800-171 rev2 Catalog
    framework_name: "NIST 800-171 rev2 Catalog"
    control_id: 1303  # SI-3-14-1 (Flaw Remediation)
    control_name: "SI-3-14-1"
    resource_type: "GithubResource"
    field_path: "security_data.total_dependabot_alerts"
    resource_type: "GithubResource"
    operation:
      name: "EQUAL"
    expected_value: 0
    tags: ["security", "github", "dependabot", "vulnerability"]
    severity: "medium"
    category: "security_assessment"

  - id: 1009
    connection_id: 1
    name: "github_no_code_scanning_alerts"
    description: "Verify that there are no unresolved code scanning alerts"  
    framework_id: 3  # NIST 800-171 rev2 Catalog
    framework_name: "NIST 800-171 rev2 Catalog"
    control_id: 1303  # SI-3-14-1 (Flaw Remediation)
    control_name: "SI-3-14-1"
    resource_type: "GithubResource"
    field_path: "security_data.total_code_scanning_alerts"
    resource_type: "GithubResource"
    operation:
      name: "EQUAL"
    expected_value: 0
    tags: ["security", "github", "code_scanning", "sast"]
    severity: "medium"
    category: "security_assessment"

  - id: 1010
    connection_id: 1
    name: "github_external_collaborators_limited"
    description: "Verify that external collaborators are limited for access control"
    framework_id: 3  # NIST 800-171 rev2 Catalog
    framework_name: "NIST 800-171 rev2 Catalog"
    control_id: 1205  # AC-3-1-6 (Least Privilege â€“ Privileged Accounts)
    control_name: "AC-3-1-6"
    resource_type: "GithubResource"
    field_path: "organization_data.total_outside_collaborators"
    resource_type: "GithubResource"
    operation:
      name: "LESS_THAN_OR_EQUAL"
    expected_value: 5
    tags: ["security", "github", "access_control", "collaborators"]
    severity: "medium"
    category: "access_control"

  - id: 1011
    connection_id: 1
    name: "github_repository_not_archived"
    description: "Verify that active repositories are not archived"
    framework_id: 3  # NIST 800-171 rev2 Catalog
    framework_name: "NIST 800-171 rev2 Catalog"
    control_id: 1200  # AC-3-1-1 (Account Management)
    control_name: "AC-3-1-1"
    resource_type: "GithubResource"
    field_path: "repository_data.basic_info.archived"
    operation:
      name: "EQUAL"
    expected_value: false
    tags: ["governance", "github", "repository_status"]
    severity: "low"
    category: "access_control"

  - id: 1012
    connection_id: 1
    name: "github_repository_not_disabled"
    description: "Verify that repositories are not disabled"
    framework_id: 3  # NIST 800-171 rev2 Catalog
    framework_name: "NIST 800-171 rev2 Catalog"
    control_id: 1200  # AC-3-1-1 (Account Management)
    control_name: "AC-3-1-1"
    resource_type: "GithubResource"
    field_path: "repository_data.basic_info.disabled"
    operation:
      name: "EQUAL"
    expected_value: false
    tags: ["governance", "github", "repository_status"]
    severity: "medium"
    category: "access_control"

  # NIST 800-53 Rev 5 - Additional Controls
  - id: 1013
    connection_id: 1
    name: "github_admin_members_limited"
    description: "Verify that admin privileges are limited (Least Privilege)"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 90   # AC-6 (Least Privilege)
    control_name: "AC-6"
    resource_type: "GithubResource"
    field_path: "organization_data.admin_members"
    operation:
      name: "LESS_THAN_OR_EQUAL"
    expected_value: 3
    tags: ["security", "github", "access_control", "least_privilege"]
    severity: "high"
    category: "access_control"

  - id: 1014
    connection_id: 1
    name: "github_has_security_features"
    description: "Verify that multiple security features are enabled"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 75   # AC-3 (Access Enforcement)
    control_name: "AC-3"
    resource_type: "GithubResource"
    field_path: "security_data.security_features_enabled"
    operation:
      name: "GREATER_THAN_OR_EQUAL"
    expected_value: 2
    tags: ["security", "github", "security_features"]
    severity: "high"
    category: "access_control"

  - id: 1015
    connection_id: 1
    name: "github_webhooks_secured"
    description: "Verify that webhooks are properly configured and limited"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 473  # MA-4 (Nonlocal Maintenance)
    control_name: "MA-4"
    resource_type: "GithubResource"
    field_path: "advanced_features_data.total_webhooks"
    operation:
      name: "LESS_THAN_OR_EQUAL"
    expected_value: 5
    tags: ["security", "github", "webhooks", "integrations"]
    severity: "medium"
    category: "maintenance"

  - id: 1016
    connection_id: 1
    name: "github_active_webhooks_monitored"
    description: "Verify that active webhooks are monitored"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 695  # SI-4 (System Monitoring)
    control_name: "SI-4"
    resource_type: "GithubResource"
    field_path: "advanced_features_data.active_webhooks"
    operation:
      name: "LESS_THAN_OR_EQUAL"
    expected_value: 3
    tags: ["security", "github", "monitoring", "webhooks"]
    severity: "medium"
    category: "system_monitoring"

  - id: 1017
    connection_id: 1
    name: "github_recent_activity"
    description: "Verify that repository shows recent development activity"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 287  # CM-8 (System Component Inventory)
    control_name: "CM-8"
    resource_type: "GithubResource"
    field_path: "repository_data.statistics.total_commits"
    operation:
      name: "GREATER_THAN"
    expected_value: 10
    tags: ["development", "github", "activity", "inventory"]
    severity: "low"
    category: "configuration_management"

  - id: 1018
    connection_id: 1
    name: "github_contributors_managed"
    description: "Verify that repository has appropriate number of contributors"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 71   # AC-2 (Account Management)
    control_name: "AC-2"
    resource_type: "GithubResource"
    field_path: "repository_data.statistics.contributors_count"
    operation:
      name: "GREATER_THAN"
    expected_value: 1
    tags: ["governance", "github", "contributors", "account_management"]
    severity: "low"
    category: "access_control"

  - id: 1019
    connection_id: 1
    name: "github_issues_enabled"
    description: "Verify that issues are enabled for incident tracking"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 549  # IR-4 (Incident Handling)
    control_name: "IR-4"
    resource_type: "GithubResource"
    field_path: "repository_data.metadata.has_issues"
    operation:
      name: "EQUAL"
    expected_value: true
    tags: ["governance", "github", "issues", "incident_response"]
    severity: "low"
    category: "incident_response"

  - id: 1020
    connection_id: 1
    name: "github_template_usage_controlled"
    description: "Verify that template repositories are appropriately configured"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 282  # CM-6 (Configuration Settings)
    control_name: "CM-6"
    resource_type: "GithubResource"
    field_path: "repository_data.metadata.is_template"
    operation:
      name: "EQUAL"
    expected_value: false
    tags: ["governance", "github", "templates", "least_functionality"]
    severity: "low"
    category: "configuration_management"

  - id: 1021
    connection_id: 1
    name: "github_collaborators_monitored"
    description: "Verify that total collaborators are within acceptable limits"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 113  # AU-6 (Audit Record Review, Analysis, and Reporting)
    control_name: "AU-6"
    resource_type: "GithubResource"
    field_path: "collaboration_data.total_collaborators"
    operation:
      name: "LESS_THAN_OR_EQUAL"
    expected_value: 20
    tags: ["security", "github", "collaborators", "audit_review"]
    severity: "medium"
    category: "audit_accountability"

  - id: 1022
    connection_id: 1
    name: "github_open_issues_managed"
    description: "Verify that open issues are actively managed"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 549  # IR-4 (Incident Handling)
    control_name: "IR-4"
    resource_type: "GithubResource"
    field_path: "collaboration_data.open_issues"
    operation:
      name: "LESS_THAN_OR_EQUAL"
    expected_value: 50
    tags: ["governance", "github", "issues", "incident_handling"]
    severity: "low"
    category: "incident_response"

  - id: 1023
    connection_id: 1
    name: "github_pull_requests_active"
    description: "Verify that pull requests indicate active development"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 275  # CM-3 (Configuration Change Control)
    control_name: "CM-3"
    resource_type: "GithubResource"
    field_path: "collaboration_data.total_pull_requests"
    operation:
      name: "GREATER_THAN"
    expected_value: 5
    tags: ["development", "github", "pull_requests", "change_control"]
    severity: "low"
    category: "configuration_management"

  - id: 1024
    connection_id: 1
    name: "github_security_advisories_monitored"
    description: "Verify that security advisories are being tracked"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 96   # AU-2 (Event Logging)
    control_name: "AU-2"
    resource_type: "GithubResource"
    field_path: "security_data.total_advisories"
    operation:
      name: "GREATER_THAN_OR_EQUAL"
    expected_value: 0
    tags: ["security", "github", "advisories", "audit_events"]
    severity: "medium"
    category: "audit_accountability"

  - id: 1025
    connection_id: 1
    name: "github_workflows_controlled"
    description: "Verify that GitHub Actions workflows are controlled and limited"
    framework_id: 3  # NIST 800-171 rev2 Catalog
    framework_name: "NIST 800-171 rev2 Catalog"
    control_id: 1201  # AC-3-1-2 (Access Enforcement)
    control_name: "AC-3-1-2"
    resource_type: "GithubResource"
    field_path: "actions_data.total_workflows"
    operation:
      name: "LESS_THAN_OR_EQUAL"
    expected_value: 10
    tags: ["security", "github", "workflows", "process_control"]
    severity: "medium"
    category: "access_control"

  - id: 1026
    connection_id: 1
    name: "github_active_workflows_monitored"
    description: "Verify that active workflows are monitored for security"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 773  # SA-9 (External System Services)
    control_name: "SA-9"
    resource_type: "GithubResource"
    field_path: "actions_data.active_workflows"
    operation:
      name: "LESS_THAN_OR_EQUAL"
    expected_value: 5
    tags: ["security", "github", "workflows", "external_software"]
    severity: "medium"
    category: "system_services_acquisition"

  - id: 1027
    connection_id: 1
    name: "github_recent_workflow_activity"
    description: "Verify that workflow runs indicate active CI/CD"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 779  # SA-11 (Developer Security and Privacy Architecture and Design Testing)
    control_name: "SA-11"
    resource_type: "GithubResource"
    field_path: "actions_data.recent_runs_count"
    operation:
      name: "GREATER_THAN"
    expected_value: 3
    tags: ["development", "github", "cicd", "security_testing"]
    severity: "low"
    category: "system_services_acquisition"

  - id: 1028
    connection_id: 1
    name: "github_organization_members_controlled"
    description: "Verify that organization membership is controlled"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 71   # AC-2 (Account Management)
    control_name: "AC-2"
    resource_type: "GithubResource"
    field_path: "organization_data.total_members"
    operation:
      name: "GREATER_THAN"
    expected_value: 1
    tags: ["security", "github", "organization", "account_management"]
    severity: "medium"
    category: "access_control"

  - id: 1029
    connection_id: 1
    name: "github_teams_structured"
    description: "Verify that teams are used for structured access control"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 75   # AC-3 (Access Enforcement)
    control_name: "AC-3"
    resource_type: "GithubResource"
    field_path: "organization_data.total_teams"
    operation:
      name: "GREATER_THAN"
    expected_value: 0
    tags: ["security", "github", "teams", "access_enforcement"]
    severity: "low"
    category: "access_control"

  - id: 1030
    connection_id: 1
    name: "github_repository_has_license"
    description: "Verify that repository has a defined license for compliance"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 595  # PM-1 (Program Management Policy and Procedures)
    control_name: "PM-1"
    resource_type: "GithubResource"
    field_path: "repository_data.metadata.license"
    operation:
      name: "NOT_EQUAL"  
    expected_value: null
    tags: ["governance", "github", "license", "program_management"]
    severity: "low"
    category: "program_management"

  # AWS Resource Checks (Original 5)
  - id: 2001
    connection_id: 2
    name: "aws_ec2_security_groups_no_open_ingress"
    description: "Verify that EC2 security groups do not allow unrestricted ingress from 0.0.0.0/0"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 75   # AC-3 (Access Enforcement)
    control_name: "AC-3"
    field_path: "security_groups"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if any security group has unrestricted ingress rules
        if not isinstance(fetched_value, dict):
            result = True  # Default to pass if no security groups
        else:
            result = True  # Default to pass
            for sg_id, sg in fetched_value.items():
                if isinstance(sg, dict):
                    ingress_rules = sg.get('inbound_rules', [])
                else:
                    # Handle Pydantic models
                    ingress_rules = getattr(sg, 'inbound_rules', [])
                
                for rule in ingress_rules:
                    cidr_blocks = rule.get('cidr_blocks', []) if isinstance(rule, dict) else getattr(rule, 'cidr_blocks', [])
                    if '0.0.0.0/0' in cidr_blocks:
                        result = False
                        break
                if not result:
                    break
    expected_value: null
    tags: ["security", "aws", "ec2", "security_groups", "network_access"]
    severity: "high"
    category: "access_control"

  - id: 2002
    connection_id: 2
    name: "aws_iam_users_have_mfa"
    description: "Verify that IAM users have multi-factor authentication enabled"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 157  # IA-2 (Identification and Authentication)
    control_name: "IA-2"
    field_path: "users"
    resource_type: "AWSIAMResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if all IAM users have MFA enabled
        if not isinstance(fetched_value, dict) or len(fetched_value) == 0:
            result = True  # Pass if no users
        else:
            result = True
            for user_name, user in fetched_value.items():
                if isinstance(user, dict):
                    mfa_devices = user.get('mfa_devices', [])
                else:
                    # Handle Pydantic models
                    mfa_devices = getattr(user, 'mfa_devices', [])
                
                if len(mfa_devices) == 0:
                    result = False
                    break
    expected_value: null
    tags: ["security", "aws", "iam", "mfa", "authentication"]
    severity: "high"
    category: "identification_authentication"

  - id: 2003
    connection_id: 2
    name: "aws_s3_buckets_encrypted"
    description: "Verify that all S3 buckets have encryption enabled"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 658  # SC-8 (Transmission Confidentiality and Integrity)
    control_name: "SC-8"
    field_path: "buckets"
    resource_type: "AWSS3Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if all S3 buckets have encryption enabled
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no buckets
        else:
            result = True
            for bucket_name, bucket in fetched_value.items():
                if isinstance(bucket, dict):
                    encryption = bucket.get('encryption', {})
                else:
                    # Handle Pydantic models
                    encryption = getattr(bucket, 'encryption', {})
                
                if not encryption or not encryption.get('enabled', False):
                    result = False
                    break
    expected_value: null
    tags: ["security", "aws", "s3", "encryption", "data_protection"]
    severity: "high"
    category: "system_communications_protection"

  - id: 2004
    connection_id: 2
    name: "aws_cloudtrail_logging_enabled"
    description: "Verify that CloudTrail logging is enabled for audit trails"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 96   # AU-2 (Event Logging)
    control_name: "AU-2"
    field_path: "trails"
    resource_type: "AWSCloudTrailResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if at least one CloudTrail is enabled and logging
        if not isinstance(fetched_value, dict):
            result = False  # Fail if no trails
        else:
            result = False
            for trail_name, trail in fetched_value.items():
                if isinstance(trail, dict):
                    is_logging = trail.get('is_logging', False)
                    status = trail.get('status', {})
                else:
                    # Handle Pydantic models
                    is_logging = getattr(trail, 'is_logging', False)
                    status = getattr(trail, 'status', {})
                    
                if is_logging and status.get('is_logging', False):
                    result = True
                    break
    expected_value: null
    tags: ["security", "aws", "cloudtrail", "logging", "audit"]
    severity: "high"
    category: "audit_accountability"

  - id: 2005
    connection_id: 2
    name: "aws_cloudwatch_log_groups_exist"
    description: "Verify that CloudWatch log groups exist for monitoring"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 695  # SI-4 (System Monitoring)
    control_name: "SI-4"
    field_path: "log_groups"
    resource_type: "AWSCloudWatchResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if CloudWatch log groups exist for monitoring
        if not isinstance(fetched_value, dict):
            result = False  # Fail if no log groups
        else:
            result = len(fetched_value) > 0  # Pass if at least one log group exists
    expected_value: null
    tags: ["security", "aws", "cloudwatch", "monitoring", "logging"]
    severity: "medium"
    category: "system_information_integrity"

  # VPC Security Checks (2006-2013)
  - id: 2006
    connection_id: 2
    name: "aws_vpc_flow_logs_enabled"
    description: "Verify that VPC flow logs are enabled for network monitoring"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 695  # SI-4 (System Monitoring)
    control_name: "SI-4"
    field_path: "vpcs"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if VPCs have flow logs enabled
        if not isinstance(fetched_value, dict):
            result = False
        else:
            result = True
            for vpc_id, vpc in fetched_value.items():
                flow_logs_enabled = False
                if isinstance(vpc, dict):
                    flow_logs_enabled = vpc.get('flow_logs_enabled', False)
                else:
                    flow_logs_enabled = getattr(vpc, 'flow_logs_enabled', False)
                
                if not flow_logs_enabled:
                    result = False
                    break
    expected_value: null
    tags: ["security", "aws", "vpc", "flow_logs", "monitoring"]
    severity: "high"
    category: "system_information_integrity"

  - id: 2007
    connection_id: 2
    name: "aws_vpc_no_default_vpc_usage"
    description: "Verify that default VPC is not used for production workloads"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 75   # AC-3 (Access Enforcement)
    control_name: "AC-3"
    field_path: "vpcs"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if default VPC is being used
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no VPCs
        else:
            result = True
            for vpc_id, vpc in fetched_value.items():
                is_default = False
                if isinstance(vpc, dict):
                    is_default = vpc.get('is_default', False)
                else:
                    is_default = getattr(vpc, 'is_default', False)
                
                if is_default:
                    result = False
                    break
    expected_value: null
    tags: ["security", "aws", "vpc", "default_vpc", "network"]
    severity: "medium"
    category: "access_control"

  - id: 2008
    connection_id: 2
    name: "aws_subnets_multi_az_deployment"
    description: "Verify that subnets are deployed across multiple availability zones"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 277  # CP-9 (System Backup)
    control_name: "CP-9"
    field_path: "subnets"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if subnets span multiple AZs
        if not isinstance(fetched_value, dict):
            result = False
        else:
            availability_zones = set()
            for subnet_id, subnet in fetched_value.items():
                az = None
                if isinstance(subnet, dict):
                    az = subnet.get('availability_zone')
                else:
                    az = getattr(subnet, 'availability_zone', None)
                
                if az:
                    availability_zones.add(az)
            
            result = len(availability_zones) >= 2  # At least 2 AZs
    expected_value: null
    tags: ["security", "aws", "subnet", "multi_az", "availability"]
    severity: "medium"
    category: "contingency_planning"

  - id: 2009
    connection_id: 2
    name: "aws_nat_gateways_deployed"
    description: "Verify that NAT gateways are deployed for private subnet internet access"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 658  # SC-8 (Transmission Confidentiality and Integrity)
    control_name: "SC-8"
    field_path: "nat_gateways"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if NAT gateways exist for private subnets
        if not isinstance(fetched_value, dict):
            result = False
        else:
            active_nat_gateways = 0
            for nat_gw_id, nat_gw in fetched_value.items():
                state = None
                if isinstance(nat_gw, dict):
                    state = nat_gw.get('state')
                else:
                    state = getattr(nat_gw, 'state', None)
                
                if state == 'available':
                    active_nat_gateways += 1
            
            result = active_nat_gateways > 0
    expected_value: null
    tags: ["security", "aws", "nat_gateway", "private_subnet", "network"]
    severity: "medium"
    category: "system_communications_protection"

  - id: 2010
    connection_id: 2
    name: "aws_route_tables_secured"
    description: "Verify that route tables have secure routing configurations"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 75   # AC-3 (Access Enforcement)
    control_name: "AC-3"
    field_path: "route_tables"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if route tables don't have overly permissive routes
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no route tables
        else:
            result = True
            for rt_id, rt in fetched_value.items():
                routes = []
                if isinstance(rt, dict):
                    routes = rt.get('routes', [])
                else:
                    routes = getattr(rt, 'routes', [])
                
                for route in routes:
                    destination = route.get('destination_cidr_block', '') if isinstance(route, dict) else getattr(route, 'destination_cidr_block', '')
                    if destination == '0.0.0.0/0':
                        # Check if it's going to an internet gateway (acceptable) or something else (risky)
                        gateway_id = route.get('gateway_id', '') if isinstance(route, dict) else getattr(route, 'gateway_id', '')
                        if not gateway_id.startswith('igw-'):
                            result = False
                            break
                if not result:
                    break
    expected_value: null
    tags: ["security", "aws", "route_table", "routing", "network"]
    severity: "high"
    category: "access_control"

  # EBS Security Checks (2011-2014)
  - id: 2011
    connection_id: 2
    name: "aws_ebs_volumes_encrypted"
    description: "Verify that EBS volumes are encrypted at rest"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 658  # SC-8 (Transmission Confidentiality and Integrity)
    control_name: "SC-8"
    field_path: "volumes"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if all EBS volumes are encrypted
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no volumes
        else:
            result = True
            for volume_id, volume in fetched_value.items():
                encrypted = False
                if isinstance(volume, dict):
                    encrypted = volume.get('encrypted', False)
                else:
                    encrypted = getattr(volume, 'encrypted', False)
                
                if not encrypted:
                    result = False
                    break
    expected_value: null
    tags: ["security", "aws", "ebs", "encryption", "storage"]
    severity: "high"
    category: "system_communications_protection"

  - id: 2012
    connection_id: 2
    name: "aws_ebs_snapshots_not_public"
    description: "Verify that EBS snapshots are not publicly accessible"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 75   # AC-3 (Access Enforcement)
    control_name: "AC-3"
    field_path: "snapshots"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if EBS snapshots are private
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no snapshots
        else:
            result = True
            for snapshot_id, snapshot in fetched_value.items():
                is_public = False
                if isinstance(snapshot, dict):
                    # Check for public permissions
                    permissions = snapshot.get('create_volume_permissions', [])
                    for perm in permissions:
                        if perm.get('Group') == 'all':
                            is_public = True
                            break
                else:
                    permissions = getattr(snapshot, 'create_volume_permissions', [])
                    for perm in permissions:
                        if getattr(perm, 'Group', None) == 'all':
                            is_public = True
                            break
                
                if is_public:
                    result = False
                    break
    expected_value: null
    tags: ["security", "aws", "ebs", "snapshot", "public_access"]
    severity: "high"
    category: "access_control"

  - id: 2013
    connection_id: 2
    name: "aws_ebs_volumes_have_backups"
    description: "Verify that EBS volumes have recent snapshots for backup"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 277  # CP-9 (System Backup)
    control_name: "CP-9"
    field_path: "volumes"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if EBS volumes have recent snapshots
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no volumes
        else:
            result = True
            # Note: This is a simplified check - in real implementation, 
            # we'd cross-reference with snapshots to verify backup recency
            for volume_id, volume in fetched_value.items():
                # For now, assume volumes in 'in-use' state are backed up
                state = None
                if isinstance(volume, dict):
                    state = volume.get('state')
                else:
                    state = getattr(volume, 'state', None)
                
                # This is a placeholder - real check would verify snapshot existence and recency
                if state not in ['in-use', 'available']:
                    result = False
                    break
    expected_value: null
    tags: ["security", "aws", "ebs", "backup", "disaster_recovery"]
    severity: "medium"
    category: "contingency_planning"

  # Enhanced S3 Security Checks (2014-2017)
  - id: 2014
    connection_id: 2
    name: "aws_s3_versioning_enabled"
    description: "Verify that S3 bucket versioning is enabled for data protection"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 277  # CP-9 (System Backup)
    control_name: "CP-9"
    field_path: "bucket_versioning"
    resource_type: "AWSS3Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if S3 bucket versioning is enabled
        if not isinstance(fetched_value, dict):
            result = False
        else:
            result = True
            for bucket_name, versioning_config in fetched_value.items():
                status = None
                if isinstance(versioning_config, dict):
                    status = versioning_config.get('Status')
                else:
                    status = getattr(versioning_config, 'Status', None)
                
                if status != 'Enabled':
                    result = False
                    break
    expected_value: null
    tags: ["security", "aws", "s3", "versioning", "data_protection"]
    severity: "medium"
    category: "contingency_planning"

  - id: 2015
    connection_id: 2
    name: "aws_s3_access_logging_enabled"
    description: "Verify that S3 bucket access logging is enabled for audit trails"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 96   # AU-2 (Event Logging)
    control_name: "AU-2"
    field_path: "bucket_logging"
    resource_type: "AWSS3Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if S3 bucket access logging is enabled
        if not isinstance(fetched_value, dict):
            result = False
        else:
            result = True
            for bucket_name, logging_config in fetched_value.items():
                # Check if logging is configured
                logging_enabled = False
                if isinstance(logging_config, dict):
                    logging_enabled = 'LoggingEnabled' in logging_config
                else:
                    logging_enabled = hasattr(logging_config, 'LoggingEnabled')
                
                if not logging_enabled:
                    result = False
                    break
    expected_value: null
    tags: ["security", "aws", "s3", "access_logging", "audit"]
    severity: "medium"
    category: "audit_accountability"

  - id: 2016
    connection_id: 2
    name: "aws_s3_public_access_blocked"
    description: "Verify that S3 bucket public access is blocked at bucket level"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 75   # AC-3 (Access Enforcement)
    control_name: "AC-3"
    field_path: "bucket_public_access"
    resource_type: "AWSS3Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if S3 bucket public access is blocked
        if not isinstance(fetched_value, dict):
            result = False
        else:
            result = True
            for bucket_name, public_access_config in fetched_value.items():
                if isinstance(public_access_config, dict):
                    block_public_acls = public_access_config.get('BlockPublicAcls', False)
                    ignore_public_acls = public_access_config.get('IgnorePublicAcls', False)
                    block_public_policy = public_access_config.get('BlockPublicPolicy', False)
                    restrict_public_buckets = public_access_config.get('RestrictPublicBuckets', False)
                else:
                    block_public_acls = getattr(public_access_config, 'BlockPublicAcls', False)
                    ignore_public_acls = getattr(public_access_config, 'IgnorePublicAcls', False)
                    block_public_policy = getattr(public_access_config, 'BlockPublicPolicy', False)
                    restrict_public_buckets = getattr(public_access_config, 'RestrictPublicBuckets', False)
                
                if not (block_public_acls and ignore_public_acls and block_public_policy and restrict_public_buckets):
                    result = False
                    break
    expected_value: null
    tags: ["security", "aws", "s3", "public_access", "data_protection"]
    severity: "high"
    category: "access_control"

  - id: 2017
    connection_id: 2
    name: "aws_s3_lifecycle_policies_configured"
    description: "Verify that S3 buckets have lifecycle policies for cost optimization"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 282  # CM-6 (Configuration Settings)
    control_name: "CM-6"
    field_path: "bucket_lifecycle"
    resource_type: "AWSS3Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if S3 buckets have lifecycle policies configured
        if not isinstance(fetched_value, dict):
            result = False
        else:
            result = True
            for bucket_name, lifecycle_config in fetched_value.items():
                has_rules = False
                if isinstance(lifecycle_config, dict):
                    rules = lifecycle_config.get('Rules', [])
                    has_rules = len(rules) > 0
                else:
                    rules = getattr(lifecycle_config, 'Rules', [])
                    has_rules = len(rules) > 0
                
                if not has_rules:
                    result = False
                    break
    expected_value: null
    tags: ["security", "aws", "s3", "lifecycle", "cost_optimization"]
    severity: "low"
    category: "configuration_management"

  # Enhanced IAM Security Checks (2018-2021)
  - id: 2018
    connection_id: 2
    name: "aws_iam_roles_have_trust_policies"
    description: "Verify that IAM roles have properly configured trust policies"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 157  # IA-2 (Identification and Authentication)
    control_name: "IA-2"
    field_path: "roles"
    resource_type: "AWSIAMResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if IAM roles have trust policies
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no roles
        else:
            result = True
            for role_name, role_data in fetched_value.items():
                trust_policy = None
                if isinstance(role_data, dict):
                    trust_policy = role_data.get('assume_role_policy_document')
                else:
                    trust_policy = getattr(role_data, 'assume_role_policy_document', None)
                
                if not trust_policy:
                    result = False
                    break
    expected_value: null
    tags: ["security", "aws", "iam", "roles", "trust_policy"]
    severity: "high"
    category: "identification_authentication"

  - id: 2019
    connection_id: 2
    name: "aws_iam_policies_least_privilege"
    description: "Verify that IAM policies follow least privilege principle"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 90   # AC-6 (Least Privilege)
    control_name: "AC-6"
    field_path: "policies"
    resource_type: "AWSIAMResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if IAM policies avoid overly broad permissions
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no policies
        else:
            result = True
            for policy_name, policy_data in fetched_value.items():
                # This is a simplified check - look for wildcard actions/resources
                policy_doc = None
                if isinstance(policy_data, dict):
                    policy_doc = policy_data.get('policy_document', {})
                else:
                    policy_doc = getattr(policy_data, 'policy_document', {})
                
                if isinstance(policy_doc, dict):
                    statements = policy_doc.get('Statement', [])
                    for statement in statements:
                        if isinstance(statement, dict):
                            actions = statement.get('Action', [])
                            resources = statement.get('Resource', [])
                            effect = statement.get('Effect', '')
                            
                            # Check for overly broad permissions
                            if effect == 'Allow':
                                if '*' in actions or '*' in resources:
                                    result = False
                                    break
                if not result:
                    break
    expected_value: null
    tags: ["security", "aws", "iam", "policies", "least_privilege"]
    severity: "high"
    category: "access_control"

  - id: 2020
    connection_id: 2
    name: "aws_iam_groups_used_for_permissions"
    description: "Verify that IAM groups are used to manage user permissions"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 71   # AC-2 (Account Management)
    control_name: "AC-2"
    field_path: "groups"
    resource_type: "AWSIAMResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if IAM groups exist and are being used
        if not isinstance(fetched_value, dict):
            result = False  # Fail if no groups
        else:
            result = len(fetched_value) > 0  # Pass if at least one group exists
    expected_value: null
    tags: ["security", "aws", "iam", "groups", "user_management"]
    severity: "medium"
    category: "access_control"

  - id: 2021
    connection_id: 2
    name: "aws_iam_users_in_groups"
    description: "Verify that IAM users are assigned to groups rather than having direct policies"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 71   # AC-2 (Account Management)
    control_name: "AC-2"
    field_path: "users"
    resource_type: "AWSIAMResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if IAM users are assigned to groups
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no users
        else:
            result = True
            for user_name, user_data in fetched_value.items():
                groups = []
                inline_policies = []
                if isinstance(user_data, dict):
                    groups = user_data.get('groups', [])
                    inline_policies = user_data.get('inline_policies', [])
                else:
                    groups = getattr(user_data, 'groups', [])
                    inline_policies = getattr(user_data, 'inline_policies', [])
                
                # User should be in at least one group and have minimal direct policies
                if len(groups) == 0 and len(inline_policies) > 0:
                    result = False
                    break
    expected_value: null
    tags: ["security", "aws", "iam", "users", "group_membership"]
    severity: "medium"
    category: "access_control"

  # Additional EC2 Security Checks (2022-2025)
  - id: 2022
    connection_id: 2
    name: "aws_ec2_instances_no_public_ip"
    description: "Verify that EC2 instances do not have public IP addresses unless necessary"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 75   # AC-3 (Access Enforcement)
    control_name: "AC-3"
    field_path: "instances"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if EC2 instances have public IP addresses
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no instances
        else:
            result = True
            for instance_id, instance in fetched_value.items():
                public_ip = None
                if isinstance(instance, dict):
                    public_ip = instance.get('public_ip_address')
                else:
                    public_ip = getattr(instance, 'public_ip_address', None)
                
                # Fail if instance has a public IP (unless it's a bastion/jump host)
                if public_ip:
                    # This is a simplified check - in reality, you'd check instance purpose/tags
                    result = False
                    break
    expected_value: null
    tags: ["security", "aws", "ec2", "public_ip", "network_exposure"]
    severity: "medium"
    category: "access_control"

  - id: 2023
    connection_id: 2
    name: "aws_ec2_instances_latest_ami"
    description: "Verify that EC2 instances are using recent AMI versions"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 679  # SI-2 (Flaw Remediation)
    control_name: "SI-2"
    field_path: "instances"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if EC2 instances are using recent AMIs
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no instances
        else:
            result = True
            for instance_id, instance in fetched_value.items():
                image_id = None
                launch_time = None
                if isinstance(instance, dict):
                    image_id = instance.get('image_id')
                    launch_time = instance.get('launch_time')
                else:
                    image_id = getattr(instance, 'image_id', None)
                    launch_time = getattr(instance, 'launch_time', None)
                
                # This is a simplified check - in reality, you'd check AMI age and patch level
                # For now, just ensure image_id exists
                if not image_id:
                    result = False
                    break
    expected_value: null
    tags: ["security", "aws", "ec2", "ami", "patch_management"]
    severity: "medium"
    category: "system_information_integrity"

  - id: 2024
    connection_id: 2
    name: "aws_ec2_key_pairs_secured"
    description: "Verify that EC2 key pairs are properly managed and secured"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 157  # IA-2 (Identification and Authentication)
    control_name: "IA-2"
    field_path: "key_pairs"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if EC2 key pairs are properly managed
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no key pairs
        else:
            result = True
            for key_pair_name, key_pair in fetched_value.items():
                key_type = None
                if isinstance(key_pair, dict):
                    key_type = key_pair.get('key_type')
                else:
                    key_type = getattr(key_pair, 'key_type', None)
                
                # Prefer RSA keys over other types for security
                if key_type and key_type not in ['rsa', 'ed25519']:
                    result = False
                    break
    expected_value: null
    tags: ["security", "aws", "ec2", "key_pairs", "authentication"]
    severity: "medium"
    category: "identification_authentication"

  - id: 2025
    connection_id: 2
    name: "aws_elastic_ips_managed"
    description: "Verify that Elastic IPs are properly managed and not orphaned"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 287  # CM-8 (System Component Inventory)
    control_name: "CM-8"
    field_path: "elastic_ips"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if Elastic IPs are associated with instances
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no Elastic IPs
        else:
            result = True
            for eip_id, eip in fetched_value.items():
                instance_id = None
                if isinstance(eip, dict):
                    instance_id = eip.get('instance_id')
                else:
                    instance_id = getattr(eip, 'instance_id', None)
                
                # Fail if EIP is not associated with an instance (orphaned)
                if not instance_id:
                    result = False
                    break
    expected_value: null
    tags: ["security", "aws", "ec2", "elastic_ip", "resource_management"]
    severity: "low"
    category: "configuration_management"

  # Batch 2: Enhanced AWS Security Checks (2026-2045)
  
  # EC2 Account & Limits Checks (2026-2030)
  - id: 2026
    connection_id: 2
    name: "aws_ec2_account_limits_monitored"
    description: "Verify that EC2 account limits are being monitored for capacity planning"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 287  # CM-8 (System Component Inventory)
    control_name: "CM-8"
    field_path: "account"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if account limits are reasonable and monitored
        if not isinstance(fetched_value, dict):
            result = False
        else:
            result = True
            limits = fetched_value.get('limits', {})
            if isinstance(limits, dict):
                max_instances = limits.get('max-instances', 0)
                max_elastic_ips = limits.get('max-elastic-ips', 0)
                # Ensure reasonable limits are set
                if max_instances < 10 or max_elastic_ips < 5:
                    result = False
    expected_value: null
    tags: ["governance", "aws", "ec2", "account_limits", "capacity_planning"]
    severity: "medium"
    category: "configuration_management"

  - id: 2027
    connection_id: 2
    name: "aws_ec2_platform_support_validated"
    description: "Verify that supported platforms are properly configured"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 282  # CM-6 (Configuration Settings)
    control_name: "CM-6"
    field_path: "account"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check supported platforms configuration
        if not isinstance(fetched_value, dict):
            result = False
        else:
            limits = fetched_value.get('limits', {})
            supported_platforms = limits.get('supported-platforms', [])
            # Prefer VPC over EC2-Classic for security
            result = 'VPC' in supported_platforms if isinstance(supported_platforms, list) else False
    expected_value: null
    tags: ["governance", "aws", "ec2", "platform", "vpc_security"]
    severity: "low"
    category: "configuration_management"

  - id: 2028
    connection_id: 2
    name: "aws_ec2_reserved_instances_managed"
    description: "Verify that reserved instances are being utilized for cost optimization"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 287  # CM-8 (System Component Inventory)
    control_name: "CM-8"
    field_path: "account"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if reserved instances are being used
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no account data
        else:
            reserved_instances = fetched_value.get('reserved_instances', [])
            # Having some reserved instances indicates cost optimization planning
            result = len(reserved_instances) > 0 if isinstance(reserved_instances, list) else False
    expected_value: null
    tags: ["governance", "aws", "ec2", "reserved_instances", "cost_optimization"]
    severity: "low"
    category: "configuration_management"

  - id: 2029
    connection_id: 2
    name: "aws_ec2_relationships_documented"
    description: "Verify that EC2 resource relationships are properly maintained"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 287  # CM-8 (System Component Inventory)
    control_name: "CM-8"
    field_path: "relationships"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if resource relationships are documented
        if not isinstance(fetched_value, dict):
            result = False
        else:
            # Verify key relationships exist
            instance_sg = fetched_value.get('instance_security_groups', {})
            result = len(instance_sg) > 0 if isinstance(instance_sg, dict) else False
    expected_value: null
    tags: ["governance", "aws", "ec2", "relationships", "documentation"]
    severity: "low"
    category: "configuration_management"

  - id: 2030
    connection_id: 2
    name: "aws_ec2_internet_gateway_controlled"
    description: "Verify that internet gateways are properly controlled and limited"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 75   # AC-3 (Access Enforcement)
    control_name: "AC-3"
    field_path: "internet_gateways"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check internet gateway configuration
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no IGWs
        else:
            # Having too many IGWs can indicate poor network segmentation
            result = len(fetched_value) <= 3  # Reasonable limit for most orgs
    expected_value: null
    tags: ["security", "aws", "ec2", "internet_gateway", "network_control"]
    severity: "medium"
    category: "access_control"

  # CloudWatch Monitoring Checks (2031-2035)
  - id: 2031
    connection_id: 2
    name: "aws_cloudwatch_alarms_configured"
    description: "Verify that CloudWatch alarms are configured for critical monitoring"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 695  # SI-4 (System Monitoring)
    control_name: "SI-4"
    field_path: "alarms"
    resource_type: "AWSCloudWatchResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if CloudWatch alarms are configured
        if not isinstance(fetched_value, dict):
            result = False
        else:
            result = len(fetched_value) >= 5  # At least 5 alarms for basic monitoring
    expected_value: null
    tags: ["security", "aws", "cloudwatch", "alarms", "monitoring"]
    severity: "high"
    category: "system_information_integrity"

  - id: 2032
    connection_id: 2
    name: "aws_cloudwatch_alarms_enabled"
    description: "Verify that CloudWatch alarms are in enabled state"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 695  # SI-4 (System Monitoring)
    control_name: "SI-4"
    field_path: "alarms"
    resource_type: "AWSCloudWatchResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if alarms are enabled
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no alarms
        else:
            result = True
            for alarm_name, alarm_data in fetched_value.items():
                enabled = False
                if isinstance(alarm_data, dict):
                    enabled = alarm_data.get('actions_enabled', True)
                else:
                    enabled = getattr(alarm_data, 'actions_enabled', True)
                
                if not enabled:
                    result = False
                    break
    expected_value: null
    tags: ["security", "aws", "cloudwatch", "alarms", "enabled_state"]
    severity: "high"
    category: "system_information_integrity"

  - id: 2033
    connection_id: 2
    name: "aws_cloudwatch_dashboards_exist"
    description: "Verify that CloudWatch dashboards exist for operational visibility"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 695  # SI-4 (System Monitoring)
    control_name: "SI-4"
    field_path: "dashboards"
    resource_type: "AWSCloudWatchResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if CloudWatch dashboards exist
        if not isinstance(fetched_value, dict):
            result = False
        else:
            result = len(fetched_value) > 0  # At least one dashboard
    expected_value: null
    tags: ["governance", "aws", "cloudwatch", "dashboards", "visibility"]
    severity: "medium"
    category: "system_information_integrity"

  - id: 2034
    connection_id: 2
    name: "aws_cloudwatch_alarm_actions_configured"
    description: "Verify that CloudWatch alarms have actions configured for notifications"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 549  # IR-4 (Incident Handling)
    control_name: "IR-4"
    field_path: "alarms"
    resource_type: "AWSCloudWatchResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if alarms have actions (SNS notifications, etc.)
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no alarms
        else:
            result = True
            for alarm_name, alarm_data in fetched_value.items():
                alarm_actions = []
                if isinstance(alarm_data, dict):
                    alarm_actions = alarm_data.get('alarm_actions', [])
                else:
                    alarm_actions = getattr(alarm_data, 'alarm_actions', [])
                
                # Alarms should have at least one action configured
                if len(alarm_actions) == 0:
                    result = False
                    break
    expected_value: null
    tags: ["security", "aws", "cloudwatch", "alarm_actions", "incident_response"]
    severity: "high"
    category: "incident_response"

  - id: 2035
    connection_id: 2
    name: "aws_cloudwatch_metrics_retention_appropriate"
    description: "Verify that CloudWatch metrics have appropriate retention periods"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 96   # AU-2 (Event Logging)
    control_name: "AU-2"
    field_path: "metrics"
    resource_type: "AWSCloudWatchResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check metrics collection for retention compliance
        if not isinstance(fetched_value, list):
            result = False
        else:
            # Verify we have metrics being collected (indicates retention is working)
            result = len(fetched_value) >= 100  # Should have substantial metrics
    expected_value: null
    tags: ["governance", "aws", "cloudwatch", "metrics", "retention"]
    severity: "medium"
    category: "audit_accountability"

  # S3 Advanced Policy Checks (2036-2039)
  - id: 2036
    connection_id: 2
    name: "aws_s3_bucket_policies_secure"
    description: "Verify that S3 bucket policies follow security best practices"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 75   # AC-3 (Access Enforcement)
    control_name: "AC-3"
    field_path: "bucket_policies"
    resource_type: "AWSS3Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check S3 bucket policies for security
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no bucket policies
        else:
            result = True
            for bucket_name, policy_data in fetched_value.items():
                if isinstance(policy_data, dict) and 'Policy' in policy_data:
                    policy = policy_data['Policy']
                    if isinstance(policy, dict):
                        statements = policy.get('Statement', [])
                        for statement in statements:
                            if isinstance(statement, dict):
                                effect = statement.get('Effect', '')
                                principal = statement.get('Principal', '')
                                # Avoid overly permissive policies
                                if effect == 'Allow' and principal == '*':
                                    result = False
                                    break
                if not result:
                    break
    expected_value: null
    tags: ["security", "aws", "s3", "bucket_policies", "access_control"]
    severity: "high"
    category: "access_control"

  - id: 2037
    connection_id: 2
    name: "aws_s3_bucket_policies_exist"
    description: "Verify that S3 buckets have explicit policies for access control"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 75   # AC-3 (Access Enforcement)
    control_name: "AC-3"
    field_path: "bucket_policies"
    resource_type: "AWSS3Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if S3 buckets have policies
        if not isinstance(fetched_value, dict):
            result = False
        else:
            # At least 50% of buckets should have explicit policies
            total_policies = len(fetched_value)
            result = total_policies >= 5  # Reasonable threshold
    expected_value: null
    tags: ["governance", "aws", "s3", "bucket_policies", "explicit_access"]
    severity: "medium"
    category: "access_control"

  - id: 2038
    connection_id: 2
    name: "aws_s3_bucket_policies_no_wildcards"
    description: "Verify that S3 bucket policies avoid wildcard resources where possible"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 90   # AC-6 (Least Privilege)
    control_name: "AC-6"
    field_path: "bucket_policies"
    resource_type: "AWSS3Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check for wildcard resources in bucket policies
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no policies
        else:
            result = True
            for bucket_name, policy_data in fetched_value.items():
                if isinstance(policy_data, dict) and 'Policy' in policy_data:
                    policy = policy_data['Policy']
                    if isinstance(policy, dict):
                        statements = policy.get('Statement', [])
                        for statement in statements:
                            if isinstance(statement, dict):
                                resources = statement.get('Resource', [])
                                if isinstance(resources, list):
                                    for resource in resources:
                                        if resource.endswith('/*') and not resource.endswith('/logs/*'):
                                            # Wildcards should be limited to specific use cases
                                            result = False
                                            break
                if not result:
                    break
    expected_value: null
    tags: ["security", "aws", "s3", "bucket_policies", "least_privilege"]
    severity: "medium"
    category: "access_control"

  - id: 2039
    connection_id: 2
    name: "aws_s3_bucket_policies_secure_transport"
    description: "Verify that S3 bucket policies enforce secure transport (HTTPS)"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 658  # SC-8 (Transmission Confidentiality and Integrity)
    control_name: "SC-8"
    field_path: "bucket_policies"
    resource_type: "AWSS3Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if bucket policies enforce HTTPS
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no policies
        else:
            secure_transport_enforced = 0
            total_policies = len(fetched_value)
            
            for bucket_name, policy_data in fetched_value.items():
                if isinstance(policy_data, dict) and 'Policy' in policy_data:
                    policy = policy_data['Policy']
                    if isinstance(policy, dict):
                        statements = policy.get('Statement', [])
                        for statement in statements:
                            if isinstance(statement, dict):
                                condition = statement.get('Condition', {})
                                # Look for SecureTransport condition
                                if 'Bool' in condition and 'aws:SecureTransport' in condition['Bool']:
                                    secure_transport_enforced += 1
                                    break
            
            # At least some policies should enforce secure transport
            result = secure_transport_enforced > 0 or total_policies == 0
    expected_value: null
    tags: ["security", "aws", "s3", "bucket_policies", "https", "secure_transport"]
    severity: "high"
    category: "system_communications_protection"

  # IAM Account & Relationship Checks (2040-2043)
  - id: 2040
    connection_id: 2
    name: "aws_iam_account_settings_secure"
    description: "Verify that IAM account settings follow security policies"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 157  # IA-2 (Identification and Authentication)
    control_name: "IA-2"
    field_path: "account"
    resource_type: "AWSIAMResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check IAM account-level settings
        if not isinstance(fetched_value, dict):
            result = False
        else:
            # Check for reasonable quotas and policies
            policies = fetched_value.get('Policies', 0)
            users_quota = fetched_value.get('UsersQuota', 0)
            groups_quota = fetched_value.get('GroupsQuota', 0)
            
            # Ensure reasonable limits are set
            result = (policies > 0 and users_quota >= 100 and groups_quota >= 50)
    expected_value: null
    tags: ["governance", "aws", "iam", "account_settings", "quotas"]
    severity: "medium"
    category: "identification_authentication"

  - id: 2041
    connection_id: 2
    name: "aws_iam_password_policy_enforced"
    description: "Verify that IAM password policy is properly configured"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 157  # IA-2 (Identification and Authentication)
    control_name: "IA-2"
    field_path: "account"
    resource_type: "AWSIAMResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check password policy settings
        if not isinstance(fetched_value, dict):
            result = False
        else:
            # Look for password policy indicators in account settings
            # This is a simplified check - real implementation would check PasswordPolicy
            account_policies = fetched_value.get('AccountMFAEnabled', False)
            result = isinstance(account_policies, bool)  # Basic validation
    expected_value: null
    tags: ["security", "aws", "iam", "password_policy", "authentication"]
    severity: "high"
    category: "identification_authentication"

  - id: 2042
    connection_id: 2
    name: "aws_iam_relationships_maintained"
    description: "Verify that IAM user-group relationships are properly maintained"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 71   # AC-2 (Account Management)
    control_name: "AC-2"
    field_path: "relationships"
    resource_type: "AWSIAMResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check IAM relationships are documented
        if not isinstance(fetched_value, dict):
            result = False
        else:
            # Verify key relationships exist
            user_groups = fetched_value.get('user_groups', {})
            result = len(user_groups) > 0 if isinstance(user_groups, dict) else False
    expected_value: null
    tags: ["governance", "aws", "iam", "relationships", "user_groups"]
    severity: "medium"
    category: "access_control"

  - id: 2043
    connection_id: 2
    name: "aws_iam_service_linked_roles_managed"
    description: "Verify that service-linked roles are properly managed and documented"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 287  # CM-8 (System Component Inventory)
    control_name: "CM-8"
    field_path: "relationships"
    resource_type: "AWSIAMResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check service-linked role management
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no relationships data
        else:
            # Look for service role relationships
            service_roles = fetched_value.get('service_roles', {})
            result = True  # Basic validation - service roles should be documented
    expected_value: null
    tags: ["governance", "aws", "iam", "service_roles", "inventory"]
    severity: "low"
    category: "configuration_management"

  # Advanced CloudTrail & Network Checks (2044-2045)
  - id: 2044
    connection_id: 2
    name: "aws_cloudtrail_tags_managed"
    description: "Verify that CloudTrail resources are properly tagged for governance"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 287  # CM-8 (System Component Inventory)
    control_name: "CM-8"
    field_path: "tags"
    resource_type: "AWSCloudTrailResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check CloudTrail tagging
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no tags data (not critical)
        else:
            # Tags should be used for governance
            result = len(fetched_value) >= 0  # Basic validation
    expected_value: null
    tags: ["governance", "aws", "cloudtrail", "tags", "resource_management"]
    severity: "low"
    category: "configuration_management"

  - id: 2045
    connection_id: 2
    name: "aws_ec2_network_interfaces_secured"
    description: "Verify that EC2 network interfaces have proper security configurations"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 75   # AC-3 (Access Enforcement)
    control_name: "AC-3"
    field_path: "network_interfaces"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check network interface security
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no network interfaces
        else:
            result = True
            for ni_id, ni_data in fetched_value.items():
                # Check for security group associations
                security_groups = []
                if isinstance(ni_data, dict):
                    security_groups = ni_data.get('security_groups', [])
                else:
                    security_groups = getattr(ni_data, 'security_groups', [])
                
                # Network interfaces should have security groups
                if len(security_groups) == 0:
                    result = False
                    break
    expected_value: null
    tags: ["security", "aws", "ec2", "network_interfaces", "security_groups"]
    severity: "medium"
    category: "access_control"

  # Batch 3: Deep Compliance & Advanced Analytics (2046-2065)
  
  # AWS EC2 Advanced Instance Checks (2046-2052)
  - id: 2046
    connection_id: 2
    name: "aws_ec2_detailed_monitoring_enabled"
    description: "Verify that EC2 instances have detailed CloudWatch monitoring enabled"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 695  # SI-4 (System Monitoring)
    control_name: "SI-4"
    field_path: "instances"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if instances have detailed monitoring enabled
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no instances
        else:
            result = True
            for instance_id, instance in fetched_value.items():
                monitoring = None
                if isinstance(instance, dict):
                    monitoring = instance.get('monitoring', {})
                else:
                    monitoring = getattr(instance, 'monitoring', {})
                
                # Check if detailed monitoring is enabled
                if isinstance(monitoring, dict):
                    state = monitoring.get('state', 'disabled')
                    if state != 'enabled':
                        result = False
                        break
    expected_value: null
    tags: ["security", "aws", "ec2", "monitoring", "cloudwatch"]
    severity: "medium"
    category: "system_information_integrity"

  - id: 2047
    connection_id: 2
    name: "aws_ec2_iam_instance_profiles_attached"
    description: "Verify that EC2 instances have IAM instance profiles for secure API access"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 157  # IA-2 (Identification and Authentication)
    control_name: "IA-2"
    field_path: "instances"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if instances have IAM instance profiles
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no instances
        else:
            result = True
            for instance_id, instance in fetched_value.items():
                iam_profile = None
                if isinstance(instance, dict):
                    iam_profile = instance.get('iam_instance_profile')
                else:
                    iam_profile = getattr(instance, 'iam_instance_profile', None)
                
                # Instances should have IAM profiles for secure API access
                if not iam_profile:
                    result = False
                    break
    expected_value: null
    tags: ["security", "aws", "ec2", "iam", "instance_profile"]
    severity: "high"
    category: "identification_authentication"

  - id: 2048
    connection_id: 2
    name: "aws_ec2_ebs_optimized_enabled"
    description: "Verify that EC2 instances have EBS optimization enabled for performance"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 282  # CM-6 (Configuration Settings)
    control_name: "CM-6"
    field_path: "instances"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if instances have EBS optimization enabled
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no instances
        else:
            result = True
            for instance_id, instance in fetched_value.items():
                ebs_optimized = False
                if isinstance(instance, dict):
                    ebs_optimized = instance.get('ebs_optimized', False)
                else:
                    ebs_optimized = getattr(instance, 'ebs_optimized', False)
                
                # EBS-backed instances should be EBS-optimized
                if not ebs_optimized:
                    result = False
                    break
    expected_value: null
    tags: ["governance", "aws", "ec2", "ebs_optimized", "performance"]
    severity: "low"
    category: "configuration_management"

  - id: 2049
    connection_id: 2
    name: "aws_ec2_instance_lifecycle_managed"
    description: "Verify that EC2 instance lifecycle is properly managed (spot vs on-demand)"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 287  # CM-8 (System Component Inventory)
    control_name: "CM-8"
    field_path: "instances"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check instance lifecycle management
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no instances
        else:
            result = True
            spot_count = 0
            total_count = len(fetched_value)
            
            for instance_id, instance in fetched_value.items():
                lifecycle = None
                if isinstance(instance, dict):
                    lifecycle = instance.get('instance_lifecycle')
                else:
                    lifecycle = getattr(instance, 'instance_lifecycle', None)
                
                if lifecycle == 'spot':
                    spot_count += 1
            
            # Ensure spot instances don't exceed 30% for stability
            if total_count > 0:
                spot_percentage = (spot_count / total_count) * 100
                result = spot_percentage <= 30
    expected_value: null
    tags: ["governance", "aws", "ec2", "lifecycle", "cost_optimization"]
    severity: "medium"
    category: "configuration_management"

  - id: 2050
    connection_id: 2
    name: "aws_ec2_instances_properly_tagged"
    description: "Verify that EC2 instances have required tags for governance"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 287  # CM-8 (System Component Inventory)
    control_name: "CM-8"
    field_path: "instances"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if instances have proper tags
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no instances
        else:
            result = True
            for instance_id, instance in fetched_value.items():
                tags = {}
                if isinstance(instance, dict):
                    tags = instance.get('tags', {})
                else:
                    tags = getattr(instance, 'tags', {})
                
                # Check for essential tags
                required_tags = ['Name', 'Environment', 'Owner']
                missing_tags = [tag for tag in required_tags if tag not in tags]
                
                if len(missing_tags) > 1:  # Allow 1 missing tag
                    result = False
                    break
    expected_value: null
    tags: ["governance", "aws", "ec2", "tags", "resource_management"]
    severity: "medium"
    category: "configuration_management"

  - id: 2051
    connection_id: 2
    name: "aws_ec2_block_device_mappings_encrypted"
    description: "Verify that EC2 instance block device mappings use encrypted volumes"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 658  # SC-8 (Transmission Confidentiality and Integrity)
    control_name: "SC-8"
    field_path: "instances"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if block device mappings are encrypted
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no instances
        else:
            result = True
            for instance_id, instance in fetched_value.items():
                block_devices = []
                if isinstance(instance, dict):
                    block_devices = instance.get('block_device_mappings', [])
                else:
                    block_devices = getattr(instance, 'block_device_mappings', [])
                
                for device in block_devices:
                    if isinstance(device, dict) and 'ebs' in device:
                        ebs = device['ebs']
                        encrypted = ebs.get('encrypted', False)
                        if not encrypted:
                            result = False
                            break
                if not result:
                    break
    expected_value: null
    tags: ["security", "aws", "ec2", "encryption", "block_devices"]
    severity: "high"
    category: "system_communications_protection"

  - id: 2052
    connection_id: 2
    name: "aws_security_groups_outbound_rules_restricted"
    description: "Verify that security groups have restrictive outbound rules"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 75   # AC-3 (Access Enforcement)
    control_name: "AC-3"
    field_path: "security_groups"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check outbound rules for security groups
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no security groups
        else:
            result = True
            for sg_id, sg in fetched_value.items():
                outbound_rules = []
                if isinstance(sg, dict):
                    outbound_rules = sg.get('outbound_rules', [])
                else:
                    outbound_rules = getattr(sg, 'outbound_rules', [])
                
                # Check for overly permissive outbound rules
                for rule in outbound_rules:
                    cidr_blocks = rule.get('cidr_blocks', []) if isinstance(rule, dict) else getattr(rule, 'cidr_blocks', [])
                    protocol = rule.get('protocol', '') if isinstance(rule, dict) else getattr(rule, 'protocol', '')
                    
                    # Flag unrestricted outbound access on sensitive protocols
                    if '0.0.0.0/0' in cidr_blocks and protocol in ['tcp', 'udp', '-1']:
                        result = False
                        break
                if not result:
                    break
    expected_value: null
    tags: ["security", "aws", "ec2", "security_groups", "outbound_rules"]
    severity: "medium"
    category: "access_control"

  # CloudWatch Advanced Monitoring (2053-2055)
  - id: 2053
    connection_id: 2
    name: "aws_cloudwatch_log_groups_encrypted"
    description: "Verify that CloudWatch log groups are encrypted with KMS keys"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 658  # SC-8 (Transmission Confidentiality and Integrity)
    control_name: "SC-8"
    field_path: "log_groups"
    resource_type: "AWSCloudWatchResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if log groups are encrypted
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no log groups
        else:
            result = True
            for lg_name, lg_data in fetched_value.items():
                kms_key_id = None
                if isinstance(lg_data, dict):
                    kms_key_id = lg_data.get('kms_key_id')
                else:
                    kms_key_id = getattr(lg_data, 'kms_key_id', None)
                
                # Log groups should be encrypted
                if not kms_key_id:
                    result = False
                    break
    expected_value: null
    tags: ["security", "aws", "cloudwatch", "encryption", "kms"]
    severity: "high"
    category: "system_communications_protection"

  - id: 2054
    connection_id: 2
    name: "aws_cloudwatch_log_groups_retention_appropriate"
    description: "Verify that CloudWatch log groups have appropriate data retention"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 96   # AU-2 (Event Logging)
    control_name: "AU-2"
    field_path: "log_groups"
    resource_type: "AWSCloudWatchResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check log retention based on stored bytes
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no log groups
        else:
            result = True
            for lg_name, lg_data in fetched_value.items():
                stored_bytes = 0
                if isinstance(lg_data, dict):
                    stored_bytes = lg_data.get('stored_bytes', 0)
                else:
                    stored_bytes = getattr(lg_data, 'stored_bytes', 0)
                
                # Large log storage indicates good retention (>1GB suggests logs are being kept)
                # Very small storage might indicate logs are being deleted too quickly
                if stored_bytes < 1000000:  # 1MB threshold - too small
                    result = False
                    break
    expected_value: null
    tags: ["governance", "aws", "cloudwatch", "retention", "audit_logs"]
    severity: "medium"
    category: "audit_accountability"

  - id: 2055
    connection_id: 2
    name: "aws_cloudwatch_log_groups_metric_filters_configured"
    description: "Verify that CloudWatch log groups have metric filters for monitoring"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 695  # SI-4 (System Monitoring)
    control_name: "SI-4"
    field_path: "log_groups"
    resource_type: "AWSCloudWatchResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if log groups have metric filters
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no log groups
        else:
            result = True
            total_with_filters = 0
            total_groups = len(fetched_value)
            
            for lg_name, lg_data in fetched_value.items():
                filter_count = 0
                if isinstance(lg_data, dict):
                    filter_count = lg_data.get('metric_filter_count', 0)
                else:
                    filter_count = getattr(lg_data, 'metric_filter_count', 0)
                
                if filter_count > 0:
                    total_with_filters += 1
            
            # At least 30% of log groups should have metric filters
            if total_groups > 0:
                percentage_with_filters = (total_with_filters / total_groups) * 100
                result = percentage_with_filters >= 30
    expected_value: null
    tags: ["security", "aws", "cloudwatch", "metric_filters", "monitoring"]
    severity: "medium"
    category: "system_information_integrity"

  # IAM Advanced Security (2056-2058)
  - id: 2056
    connection_id: 2
    name: "aws_iam_users_access_keys_rotated"
    description: "Verify that IAM user access keys are properly managed and rotated"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 157  # IA-2 (Identification and Authentication)
    control_name: "IA-2"
    field_path: "users"
    resource_type: "AWSIAMResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check access key management
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no users
        else:
            result = True
            for user_name, user_data in fetched_value.items():
                access_keys = []
                if isinstance(user_data, dict):
                    access_keys = user_data.get('access_keys', [])
                else:
                    access_keys = getattr(user_data, 'access_keys', [])
                
                # Users should not have more than 2 access keys
                if len(access_keys) > 2:
                    result = False
                    break
                
                # Check for active keys
                active_keys = [key for key in access_keys if key.get('status') == 'Active']
                if len(active_keys) > 1:
                    result = False
                    break
    expected_value: null
    tags: ["security", "aws", "iam", "access_keys", "key_rotation"]
    severity: "high"
    category: "identification_authentication"

  - id: 2057
    connection_id: 2
    name: "aws_iam_users_console_access_controlled"
    description: "Verify that IAM users have controlled console access"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 71   # AC-2 (Account Management)
    control_name: "AC-2"
    field_path: "users"
    resource_type: "AWSIAMResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check console access management
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no users
        else:
            result = True
            users_with_console = 0
            total_users = len(fetched_value)
            
            for user_name, user_data in fetched_value.items():
                login_profile = None
                if isinstance(user_data, dict):
                    login_profile = user_data.get('login_profile')
                else:
                    login_profile = getattr(user_data, 'login_profile', None)
                
                if login_profile:
                    users_with_console += 1
            
            # Limit console access - max 50% of users should have console access
            if total_users > 0:
                console_percentage = (users_with_console / total_users) * 100
                result = console_percentage <= 50
    expected_value: null
    tags: ["security", "aws", "iam", "console_access", "user_management"]
    severity: "medium"
    category: "access_control"

  - id: 2058
    connection_id: 2
    name: "aws_iam_users_path_organized"
    description: "Verify that IAM users are organized with proper path structure"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 287  # CM-8 (System Component Inventory)
    control_name: "CM-8"
    field_path: "users"
    resource_type: "AWSIAMResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check user path organization
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no users
        else:
            result = True
            users_with_paths = 0
            total_users = len(fetched_value)
            
            for user_name, user_data in fetched_value.items():
                path = '/'
                if isinstance(user_data, dict):
                    path = user_data.get('path', '/')
                else:
                    path = getattr(user_data, 'path', '/')
                
                # Count users with organizational paths (not root path)
                if path != '/':
                    users_with_paths += 1
            
            # At least 30% of users should have organizational paths
            if total_users > 0:
                path_percentage = (users_with_paths / total_users) * 100
                result = path_percentage >= 30 or total_users <= 5  # Small orgs exception
    expected_value: null
    tags: ["governance", "aws", "iam", "user_paths", "organization"]
    severity: "low"
    category: "configuration_management"

  # GitHub Advanced Analytics (2059-2065)
  - id: 2059
    connection_id: 1
    name: "github_repository_size_appropriate"
    description: "Verify that GitHub repository size is within reasonable limits"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 287  # CM-8 (System Component Inventory)
    control_name: "CM-8"
    field_path: "repository_data.basic_info.size"
    resource_type: "GithubResource"
    operation:
      name: "LESS_THAN"
    expected_value: 100000  # 100MB limit
    tags: ["governance", "github", "repository_size", "resource_management"]
    severity: "low"
    category: "configuration_management"

  - id: 2060
    connection_id: 1
    name: "github_repository_language_documented"
    description: "Verify that GitHub repository has a primary language defined"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 287  # CM-8 (System Component Inventory)
    control_name: "CM-8"
    field_path: "repository_data.basic_info.language"
    resource_type: "GithubResource"
    operation:
      name: "NOT_EQUAL"
    expected_value: null
    tags: ["governance", "github", "language", "documentation"]
    severity: "low"
    category: "configuration_management"

  - id: 2061
    connection_id: 1
    name: "github_repository_creation_date_reasonable"
    description: "Verify that repository creation date indicates active development"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 287  # CM-8 (System Component Inventory)
    control_name: "CM-8"
    field_path: "repository_data.basic_info.created_at"
    resource_type: "GithubResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if repository creation date is reasonable (not too old without activity)
        if not fetched_value:
            result = False
        else:
            from datetime import datetime, timezone
            try:
                # Parse ISO format date
                created_date = datetime.fromisoformat(fetched_value.replace('Z', '+00:00'))
                current_date = datetime.now(timezone.utc)
                days_old = (current_date - created_date).days
                
                # Repositories older than 3 years should show recent activity
                # This is a basic check - real implementation would cross-reference with push dates
                result = days_old <= 1095  # 3 years
            except:
                result = False
    expected_value: null
    tags: ["governance", "github", "creation_date", "active_development"]
    severity: "low"
    category: "configuration_management"

  - id: 2062
    connection_id: 1
    name: "github_repository_multiple_languages"
    description: "Verify repository language diversity for complexity assessment"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 287  # CM-8 (System Component Inventory)
    control_name: "CM-8"
    field_path: "repository_data.statistics.languages"
    resource_type: "GithubResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check language diversity
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no language data
        else:
            # Count languages with significant presence (>5% of codebase)
            total_bytes = sum(fetched_value.values())
            significant_languages = 0
            
            for language, bytes_count in fetched_value.items():
                percentage = (bytes_count / total_bytes) * 100 if total_bytes > 0 else 0
                if percentage >= 5:
                    significant_languages += 1
            
            # 1-3 significant languages is good, too many might indicate complexity issues
            result = 1 <= significant_languages <= 3
    expected_value: null
    tags: ["governance", "github", "languages", "complexity_assessment"]
    severity: "low"
    category: "configuration_management"

  - id: 2063
    connection_id: 1
    name: "github_repository_code_frequency_active"
    description: "Verify that repository shows consistent development activity"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 287  # CM-8 (System Component Inventory)
    control_name: "CM-8"
    field_path: "repository_data.statistics.code_frequency"
    resource_type: "GithubResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check code frequency for consistent activity
        if not isinstance(fetched_value, list):
            result = False
        else:
            # Check if there's recent activity in code frequency data
            result = len(fetched_value) >= 10  # Should have at least 10 weeks of data
    expected_value: null
    tags: ["governance", "github", "code_frequency", "development_activity"]
    severity: "low"
    category: "configuration_management"

  - id: 2064
    connection_id: 1
    name: "github_repository_tags_managed"
    description: "Verify that repository uses tags for version management"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 275  # CM-3 (Configuration Change Control)
    control_name: "CM-3"
    field_path: "advanced_features_data.total_tags"
    resource_type: "GithubResource"
    operation:
      name: "GREATER_THAN"
    expected_value: 0
    tags: ["governance", "github", "tags", "version_management"]
    severity: "low"  
    category: "configuration_management"

  - id: 2065
    connection_id: 1
    name: "github_cross_resource_security_consistency"
    description: "Verify consistency of security settings across repository features"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 75   # AC-3 (Access Enforcement)
    control_name: "AC-3"
    field_path: "security_data.security_features_enabled"
    resource_type: "GithubResource"
    operation:
      name: "custom"
      custom_logic: |
        # Cross-check security feature consistency
        # This check validates that if advanced security is enabled, 
        # related features should also be properly configured
        if not isinstance(fetched_value, int):
            result = False
        else:
            # If organization has multiple security features enabled,
            # it indicates good security posture consistency
            result = fetched_value >= 3  # At least 3 security features should be enabled
    expected_value: null
    tags: ["security", "github", "cross_resource", "security_consistency"]
    severity: "medium"
    category: "access_control"

  # Batch 4: Advanced Organizational & Cross-Resource Compliance (2066-2085)
  
  # AWS Advanced Platform & Multi-Resource Checks (2066-2073)
  - id: 2066
    connection_id: 2
    name: "aws_ec2_platform_consistency"
    description: "Verify that EC2 instances use consistent platform configurations"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 282  # CM-6 (Configuration Settings)
    control_name: "CM-6"
    field_path: "instances"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check platform consistency across instances
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no instances
        else:
            platforms = {}
            for instance_id, instance in fetched_value.items():
                platform = None
                if isinstance(instance, dict):
                    platform = instance.get('platform', 'linux')
                else:
                    platform = getattr(instance, 'platform', 'linux')
                
                platforms[platform] = platforms.get(platform, 0) + 1
            
            # Organization should not have too many different platforms
            result = len(platforms) <= 2  # Max 2 different platforms
    expected_value: null
    tags: ["governance", "aws", "ec2", "platform", "standardization"]
    severity: "low"
    category: "configuration_management"

  - id: 2067
    connection_id: 2
    name: "aws_vpc_subnet_availability_zone_distribution"
    description: "Verify that VPC subnets are properly distributed across availability zones"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 277  # CP-9 (System Backup)
    control_name: "CP-9"
    field_path: "subnets"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check AZ distribution for subnets within each VPC
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no subnets
        else:
            vpc_az_distribution = {}
            for subnet_id, subnet in fetched_value.items():
                vpc_id = None
                az = None
                if isinstance(subnet, dict):
                    vpc_id = subnet.get('vpc_id')
                    az = subnet.get('availability_zone')
                else:
                    vpc_id = getattr(subnet, 'vpc_id', None)
                    az = getattr(subnet, 'availability_zone', None)
                
                if vpc_id and az:
                    if vpc_id not in vpc_az_distribution:
                        vpc_az_distribution[vpc_id] = set()
                    vpc_az_distribution[vpc_id].add(az)
            
            # Each VPC should have subnets in at least 2 AZs for redundancy
            result = all(len(azs) >= 2 for azs in vpc_az_distribution.values()) if vpc_az_distribution else True
    expected_value: null
    tags: ["security", "aws", "vpc", "subnet", "high_availability"]
    severity: "medium"
    category: "contingency_planning"

  - id: 2068
    connection_id: 2
    name: "aws_security_groups_naming_convention"
    description: "Verify that security groups follow proper naming conventions"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 287  # CM-8 (System Component Inventory)
    control_name: "CM-8"
    field_path: "security_groups"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check security group naming patterns
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no security groups
        else:
            result = True
            properly_named = 0
            total_groups = len(fetched_value)
            
            for sg_id, sg in fetched_value.items():
                group_name = ''
                if isinstance(sg, dict):
                    group_name = sg.get('group_name', '')
                else:
                    group_name = getattr(sg, 'group_name', '')
                
                # Check for meaningful naming (not just default or random)
                if (group_name and group_name != 'default' and 
                    len(group_name) >= 5 and not group_name.startswith('sg-')):
                    properly_named += 1
            
            # At least 70% should have proper names
            if total_groups > 0:
                naming_percentage = (properly_named / total_groups) * 100
                result = naming_percentage >= 70
    expected_value: null
    tags: ["governance", "aws", "security_groups", "naming", "standards"]
    severity: "low"
    category: "configuration_management"

  - id: 2069
    connection_id: 2
    name: "aws_instance_security_group_associations"
    description: "Verify that EC2 instances have appropriate security group associations"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 75   # AC-3 (Access Enforcement)
    control_name: "AC-3"
    field_path: "instances"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check instance security group associations
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no instances
        else:
            result = True
            for instance_id, instance in fetched_value.items():
                security_groups = []
                if isinstance(instance, dict):
                    security_groups = instance.get('security_groups', [])
                else:
                    security_groups = getattr(instance, 'security_groups', [])
                
                # Instances should have 1-3 security groups (not too few, not too many)
                if len(security_groups) < 1 or len(security_groups) > 3:
                    result = False
                    break
    expected_value: null
    tags: ["security", "aws", "ec2", "security_groups", "associations"]
    severity: "medium"
    category: "access_control"

  - id: 2070
    connection_id: 2
    name: "aws_cloudwatch_dashboard_coverage"
    description: "Verify that CloudWatch dashboards provide comprehensive coverage"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 695  # SI-4 (System Monitoring)
    control_name: "SI-4"
    field_path: "dashboards"
    resource_type: "AWSCloudWatchResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check dashboard coverage and utility
        if not isinstance(fetched_value, dict):
            result = False  # Should have dashboards
        else:
            result = True
            total_dashboards = len(fetched_value)
            
            # Should have at least 2 dashboards for proper monitoring coverage
            if total_dashboards < 2:
                result = False
            
            # Check for dashboard naming patterns indicating purpose
            purpose_dashboards = 0
            for dashboard_name in fetched_value.keys():
                if any(keyword in dashboard_name.lower() for keyword in 
                      ['prod', 'dev', 'test', 'monitor', 'ops', 'security', 'app']):
                    purpose_dashboards += 1
            
            # At least 50% should have purpose-indicating names
            if total_dashboards > 0:
                purpose_percentage = (purpose_dashboards / total_dashboards) * 100
                result = result and (purpose_percentage >= 50)
    expected_value: null
    tags: ["governance", "aws", "cloudwatch", "dashboards", "monitoring_coverage"]
    severity: "medium"
    category: "system_information_integrity"

  - id: 2071
    connection_id: 2
    name: "aws_iam_cross_resource_consistency"
    description: "Verify consistency between IAM users, groups, and roles"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 71   # AC-2 (Account Management)
    control_name: "AC-2"
    field_path: "users"
    resource_type: "AWSIAMResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check cross-resource IAM consistency
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no users
        else:
            total_users = len(fetched_value)
            users_with_groups = 0
            
            for user_name, user_data in fetched_value.items():
                groups = []
                if isinstance(user_data, dict):
                    groups = user_data.get('groups', [])
                else:
                    groups = getattr(user_data, 'groups', [])
                
                if len(groups) > 0:
                    users_with_groups += 1
            
            # At least 60% of users should be in groups (good practice)
            if total_users > 0:
                group_membership_percentage = (users_with_groups / total_users) * 100
                result = group_membership_percentage >= 60
            else:
                result = True
    expected_value: null
    tags: ["governance", "aws", "iam", "cross_resource", "consistency"]
    severity: "medium"
    category: "access_control"

  - id: 2072
    connection_id: 2
    name: "aws_s3_bucket_cross_reference_analysis"
    description: "Verify S3 bucket configurations are consistent across features"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 282  # CM-6 (Configuration Settings)
    control_name: "CM-6"
    field_path: "buckets"
    resource_type: "AWSS3Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Cross-reference S3 bucket security features
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no buckets
        else:
            result = True
            buckets_with_comprehensive_security = 0
            total_buckets = len(fetched_value)
            
            for bucket_name, bucket_data in fetched_value.items():
                security_features = 0
                
                if isinstance(bucket_data, dict):
                    # Count security features
                    encryption = bucket_data.get('encryption', {})
                    if encryption and encryption.get('enabled'):
                        security_features += 1
                    
                    # Check versioning (assume we have this data)
                    # Check public access blocking (assume we have this data)  
                    # Check logging (assume we have this data)
                    # For now, use encryption as primary indicator
                    
                if security_features >= 1:  # At least encryption
                    buckets_with_comprehensive_security += 1
            
            # At least 80% of buckets should have security features
            if total_buckets > 0:
                security_percentage = (buckets_with_comprehensive_security / total_buckets) * 100
                result = security_percentage >= 80
    expected_value: null
    tags: ["security", "aws", "s3", "cross_reference", "comprehensive_security"]
    severity: "high"
    category: "system_communications_protection"

  - id: 2073
    connection_id: 2
    name: "aws_cloudtrail_multi_region_coverage"
    description: "Verify CloudTrail provides appropriate multi-region coverage"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 96   # AU-2 (Event Logging)
    control_name: "AU-2"
    field_path: "trails"
    resource_type: "AWSCloudTrailResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check CloudTrail coverage patterns
        if not isinstance(fetched_value, dict):
            result = False  # Should have trails
        else:
            result = True
            active_trails = 0
            total_trails = len(fetched_value)
            
            for trail_name, trail_data in fetched_value.items():
                is_logging = False
                if isinstance(trail_data, dict):
                    is_logging = trail_data.get('is_logging', False)
                    status = trail_data.get('status', {})
                    if status and status.get('is_logging', False):
                        is_logging = True
                else:
                    is_logging = getattr(trail_data, 'is_logging', False)
                
                if is_logging:
                    active_trails += 1
            
            # Should have at least 1 active trail, but not too many (cost efficiency)
            result = 1 <= active_trails <= 3
    expected_value: null
    tags: ["security", "aws", "cloudtrail", "multi_region", "coverage"]
    severity: "high"
    category: "audit_accountability"

  # GitHub Advanced Organizational Governance (2074-2081)
  - id: 2074
    connection_id: 1
    name: "github_organization_structure_governance"
    description: "Verify GitHub organization has proper governance structure"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 71   # AC-2 (Account Management)
    control_name: "AC-2"
    field_path: "organization_data.total_teams"
    resource_type: "GithubResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check organization governance via team structure
        if not isinstance(fetched_value, int):
            result = False
        else:
            # Organizations should have structured teams (but not too many to manage)
            result = 2 <= fetched_value <= 20
    expected_value: null
    tags: ["governance", "github", "organization", "teams", "structure"]
    severity: "medium"
    category: "access_control"

  - id: 2075
    connection_id: 1
    name: "github_member_to_admin_ratio"
    description: "Verify appropriate ratio of members to admins in organization"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 90   # AC-6 (Least Privilege)
    control_name: "AC-6"
    field_path: "organization_data.total_members"
    resource_type: "GithubResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check member to admin ratio for least privilege
        if not isinstance(fetched_value, int):
            result = True  # Pass if no member data
        else:
            total_members = fetched_value
            # We need to cross-reference with admin_members from another field
            # For now, ensure we have reasonable membership size
            result = total_members >= 2  # At least 2 members for collaboration
    expected_value: null
    tags: ["security", "github", "organization", "least_privilege", "member_ratio"]
    severity: "medium"
    category: "access_control"

  - id: 2076
    connection_id: 1
    name: "github_repository_activity_consistency"
    description: "Verify consistent development activity across repository metrics"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 287  # CM-8 (System Component Inventory)
    control_name: "CM-8"
    field_path: "collaboration_data.total_pull_requests"
    resource_type: "GithubResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check for consistent activity patterns
        if not isinstance(fetched_value, int):
            result = False
        else:
            pull_requests = fetched_value
            # Active repositories should have reasonable PR activity
            # This indicates healthy development practices
            result = pull_requests >= 1  # At least some collaborative development
    expected_value: null
    tags: ["governance", "github", "activity", "development", "consistency"]
    severity: "low"
    category: "configuration_management"

  - id: 2077
    connection_id: 1
    name: "github_security_policy_completeness"
    description: "Verify comprehensive security policy implementation"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 75   # AC-3 (Access Enforcement)
    control_name: "AC-3"
    field_path: "security_data.security_features_enabled"
    resource_type: "GithubResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check completeness of security implementation
        if not isinstance(fetched_value, int):
            result = False
        else:
            security_features = fetched_value
            # Comprehensive security should have multiple layers
            result = security_features >= 4  # At least 4 security features
    expected_value: null
    tags: ["security", "github", "security_policy", "comprehensive", "defense_in_depth"]
    severity: "high"
    category: "access_control"

  - id: 2078
    connection_id: 1
    name: "github_collaboration_balance"
    description: "Verify balanced collaboration patterns in repository"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 113  # AU-6 (Audit Record Review, Analysis, and Reporting)
    control_name: "AU-6"
    field_path: "collaboration_data.total_collaborators"
    resource_type: "GithubResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check collaboration balance
        if not isinstance(fetched_value, int):
            result = True  # Pass if no data
        else:
            collaborators = fetched_value
            # Should have reasonable collaboration (not too few, not too many to manage)
            result = 2 <= collaborators <= 50
    expected_value: null
    tags: ["governance", "github", "collaboration", "balance", "team_size"]
    severity: "low"
    category: "audit_accountability"

  - id: 2079
    connection_id: 1
    name: "github_issue_management_effectiveness"
    description: "Verify effective issue management practices"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 549  # IR-4 (Incident Handling)
    control_name: "IR-4"
    field_path: "collaboration_data.open_issues"
    resource_type: "GithubResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check issue management effectiveness
        if not isinstance(fetched_value, int):
            result = True  # Pass if no data
        else:
            open_issues = fetched_value
            # Should have some issues (shows engagement) but not too many (shows management)
            result = 0 <= open_issues <= 100  # Reasonable range
    expected_value: null
    tags: ["governance", "github", "issues", "management", "incident_handling"]
    severity: "low"
    category: "incident_response"

  - id: 2080
    connection_id: 1
    name: "github_workflow_security_integration"
    description: "Verify security integration in CI/CD workflows"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 773  # SA-9 (External System Services)
    control_name: "SA-9"
    field_path: "actions_data.active_workflows"
    resource_type: "GithubResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check workflow security integration
        if not isinstance(fetched_value, int):
            result = True  # Pass if no workflows
        else:
            active_workflows = fetched_value
            # Should have some active workflows for CI/CD but not too many to manage
            result = 1 <= active_workflows <= 15
    expected_value: null
    tags: ["security", "github", "workflows", "cicd", "integration"]
    severity: "medium"
    category: "system_services_acquisition"

  - id: 2081
    connection_id: 1
    name: "github_advanced_features_utilization"
    description: "Verify proper utilization of GitHub advanced features"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 282  # CM-6 (Configuration Settings)
    control_name: "CM-6"
    field_path: "advanced_features_data.total_webhooks"
    resource_type: "GithubResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check advanced features utilization
        if not isinstance(fetched_value, int):
            result = True  # Pass if no data
        else:
            webhooks = fetched_value
            # Should use webhooks for integration but not excessively
            result = 0 <= webhooks <= 10  # Reasonable webhook usage
    expected_value: null
    tags: ["governance", "github", "advanced_features", "webhooks", "integration"]
    severity: "low"
    category: "configuration_management"

  # Cross-Platform Advanced Compliance (2082-2085)
  - id: 2082
    connection_id: 2
    name: "aws_resource_tagging_consistency"
    description: "Verify consistent tagging strategy across EC2 resources"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 287  # CM-8 (System Component Inventory)
    control_name: "CM-8"
    field_path: "instances"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check tagging consistency across resources
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no instances
        else:
            tag_keys_frequency = {}
            total_resources = len(fetched_value)
            
            for instance_id, instance in fetched_value.items():
                tags = {}
                if isinstance(instance, dict):
                    tags = instance.get('tags', {})
                else:
                    tags = getattr(instance, 'tags', {})
                
                for tag_key in tags.keys():
                    tag_keys_frequency[tag_key] = tag_keys_frequency.get(tag_key, 0) + 1
            
            # Check for common organizational tags
            common_tags = ['Environment', 'Owner', 'Project', 'Name']
            consistent_tags = 0
            
            for tag in common_tags:
                if tag in tag_keys_frequency:
                    # Tag should be used in at least 50% of resources
                    if tag_keys_frequency[tag] >= (total_resources * 0.5):
                        consistent_tags += 1
            
            result = consistent_tags >= 2  # At least 2 consistent organizational tags
    expected_value: null
    tags: ["governance", "aws", "tagging", "consistency", "resource_management"]
    severity: "medium"
    category: "configuration_management"

  - id: 2083
    connection_id: 2
    name: "aws_network_security_layering"
    description: "Verify layered network security approach with multiple controls"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 75   # AC-3 (Access Enforcement)
    control_name: "AC-3"
    field_path: "security_groups"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check for layered security approach
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no security groups
        else:
            result = True
            security_layers = 0
            
            for sg_id, sg in fetched_value.items():
                inbound_rules = []
                outbound_rules = []
                
                if isinstance(sg, dict):
                    inbound_rules = sg.get('inbound_rules', [])
                    outbound_rules = sg.get('outbound_rules', [])
                else:
                    inbound_rules = getattr(sg, 'inbound_rules', [])
                    outbound_rules = getattr(sg, 'outbound_rules', [])
                
                # Count security groups with both inbound and outbound rules
                if len(inbound_rules) > 0 and len(outbound_rules) > 0:
                    security_layers += 1
            
            # At least 50% of security groups should have both types of rules
            total_groups = len(fetched_value)
            if total_groups > 0:
                layered_percentage = (security_layers / total_groups) * 100
                result = layered_percentage >= 50
    expected_value: null
    tags: ["security", "aws", "network", "layered_security", "defense_in_depth"]
    severity: "high"
    category: "access_control"

  - id: 2084
    connection_id: 2
    name: "aws_monitoring_coverage_assessment"
    description: "Verify comprehensive monitoring coverage across AWS services"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 695  # SI-4 (System Monitoring)
    control_name: "SI-4"
    field_path: "log_groups"
    resource_type: "AWSCloudWatchResource"
    operation:
      name: "custom"
      custom_logic: |
        # Assess monitoring coverage breadth
        if not isinstance(fetched_value, dict):
            result = False  # Should have monitoring
        else:
            log_groups = len(fetched_value)
            total_storage = 0
            
            for lg_name, lg_data in fetched_value.items():
                stored_bytes = 0
                if isinstance(lg_data, dict):
                    stored_bytes = lg_data.get('stored_bytes', 0)
                else:
                    stored_bytes = getattr(lg_data, 'stored_bytes', 0)
                total_storage += stored_bytes
            
            # Should have multiple log groups and significant log volume
            result = log_groups >= 3 and total_storage > 10000000  # 10MB+ total
    expected_value: null
    tags: ["security", "aws", "monitoring", "coverage", "comprehensive"]
    severity: "high"
    category: "system_information_integrity"

  - id: 2085
    connection_id: 2
    name: "aws_identity_access_maturity"
    description: "Verify mature IAM implementation with comprehensive controls"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 157  # IA-2 (Identification and Authentication)
    control_name: "IA-2"
    field_path: "users"
    resource_type: "AWSIAMResource"
    operation:
      name: "custom"
      custom_logic: |
        # Assess IAM maturity through user management patterns
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no users
        else:
            total_users = len(fetched_value)
            users_with_mfa = 0
            users_in_groups = 0
            users_with_access_keys = 0
            
            for user_name, user_data in fetched_value.items():
                mfa_devices = []
                groups = []
                access_keys = []
                
                if isinstance(user_data, dict):
                    mfa_devices = user_data.get('mfa_devices', [])
                    groups = user_data.get('groups', [])
                    access_keys = user_data.get('access_keys', [])
                else:
                    mfa_devices = getattr(user_data, 'mfa_devices', [])
                    groups = getattr(user_data, 'groups', [])
                    access_keys = getattr(user_data, 'access_keys', [])
                
                if len(mfa_devices) > 0:
                    users_with_mfa += 1
                if len(groups) > 0:
                    users_in_groups += 1
                if len(access_keys) > 0:
                    users_with_access_keys += 1
            
            # Mature IAM: high MFA adoption, group usage, controlled access keys
            if total_users > 0:
                mfa_percentage = (users_with_mfa / total_users) * 100
                group_percentage = (users_in_groups / total_users) * 100
                result = mfa_percentage >= 80 and group_percentage >= 60
            else:
                result = True
    expected_value: null
    tags: ["security", "aws", "iam", "maturity", "comprehensive"]
    severity: "high"
    category: "identification_authentication"

  # Batch 5: Advanced Security & Compliance Intelligence (2086-2105)
  
  # AWS Advanced Security Intelligence (2086-2093)
  - id: 2086
    connection_id: 2
    name: "aws_ec2_network_interface_security"
    description: "Verify EC2 network interfaces have proper security configurations"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 75   # AC-3 (Access Enforcement)
    control_name: "AC-3"
    field_path: "network_interfaces"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check network interface security configurations
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no network interfaces
        else:
            result = True
            for ni_id, ni_data in fetched_value.items():
                # Check source/destination check
                source_dest_check = True
                if isinstance(ni_data, dict):
                    source_dest_check = ni_data.get('source_dest_check', True)
                else:
                    source_dest_check = getattr(ni_data, 'source_dest_check', True)
                
                # Network interfaces should have source/dest check enabled (unless NAT)
                # For most cases, this should be True for security
                if not source_dest_check:
                    # This might be intentional for NAT instances, so we'll be lenient
                    pass  # Allow this for now
    expected_value: null
    tags: ["security", "aws", "ec2", "network_interfaces", "source_dest_check"]
    severity: "medium"
    category: "access_control"

  - id: 2087
    connection_id: 2
    name: "aws_ec2_instance_metadata_security"
    description: "Verify EC2 instances use secure metadata service configuration"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 658  # SC-8 (Transmission Confidentiality and Integrity)
    control_name: "SC-8"
    field_path: "instances"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check metadata service security (IMDSv2 enforcement)
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no instances
        else:
            result = True
            for instance_id, instance in fetched_value.items():
                # Check for instance metadata options (if available in data)
                # For now, verify instance has security groups (indirect security indicator)
                security_groups = []
                if isinstance(instance, dict):
                    security_groups = instance.get('security_groups', [])
                else:
                    security_groups = getattr(instance, 'security_groups', [])
                
                # Instances should have security groups for metadata access control
                if len(security_groups) == 0:
                    result = False
                    break
    expected_value: null
    tags: ["security", "aws", "ec2", "metadata", "imdsv2"]
    severity: "high"
    category: "system_communications_protection"

  - id: 2088
    connection_id: 2
    name: "aws_ec2_placement_group_optimization"
    description: "Verify EC2 instances use placement groups appropriately for performance"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 282  # CM-6 (Configuration Settings)
    control_name: "CM-6"
    field_path: "instances"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check placement group usage patterns
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no instances
        else:
            total_instances = len(fetched_value)
            instances_in_same_az = {}
            
            for instance_id, instance in fetched_value.items():
                az = None
                if isinstance(instance, dict):
                    az = instance.get('availability_zone')
                else:
                    az = getattr(instance, 'availability_zone', None)
                
                if az:
                    instances_in_same_az[az] = instances_in_same_az.get(az, 0) + 1
            
            # If many instances in same AZ, should consider placement groups
            max_instances_per_az = max(instances_in_same_az.values()) if instances_in_same_az else 0
            result = max_instances_per_az <= 10 or total_instances <= 5  # Reasonable thresholds
    expected_value: null
    tags: ["governance", "aws", "ec2", "placement_groups", "performance"]
    severity: "low"
    category: "configuration_management"

  - id: 2089
    connection_id: 2
    name: "aws_iam_role_trust_relationship_security"
    description: "Verify IAM roles have secure trust relationships without wildcards"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 90   # AC-6 (Least Privilege)
    control_name: "AC-6"
    field_path: "roles"
    resource_type: "AWSIAMResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check IAM role trust policies for security
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no roles
        else:
            result = True
            for role_name, role_data in fetched_value.items():
                trust_policy = None
                if isinstance(role_data, dict):
                    trust_policy = role_data.get('assume_role_policy_document')
                else:
                    trust_policy = getattr(role_data, 'assume_role_policy_document', None)
                
                # Basic check: role should have some trust policy
                if not trust_policy:
                    result = False
                    break
                
                # Advanced check could parse policy for wildcard principals
                # For now, just ensure policy exists
    expected_value: null
    tags: ["security", "aws", "iam", "roles", "trust_policy"]
    severity: "high"
    category: "access_control"

  - id: 2090
    connection_id: 2
    name: "aws_s3_bucket_intelligent_tiering"
    description: "Verify S3 buckets use intelligent storage optimization strategies"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 282  # CM-6 (Configuration Settings)
    control_name: "CM-6"
    field_path: "buckets"
    resource_type: "AWSS3Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check S3 bucket storage optimization
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no buckets
        else:
            result = True
            total_buckets = len(fetched_value)
            optimized_buckets = 0
            
            for bucket_name, bucket_data in fetched_value.items():
                # Check for optimization indicators (encryption, lifecycle, etc.)
                encryption_enabled = False
                if isinstance(bucket_data, dict):
                    encryption = bucket_data.get('encryption', {})
                    if encryption and encryption.get('enabled'):
                        encryption_enabled = True
                
                # Consider encrypted buckets as optimized (security optimization)
                if encryption_enabled:
                    optimized_buckets += 1
            
            # At least 70% of buckets should have some optimization
            if total_buckets > 0:
                optimization_percentage = (optimized_buckets / total_buckets) * 100
                result = optimization_percentage >= 70
    expected_value: null
    tags: ["governance", "aws", "s3", "optimization", "intelligent_tiering"]
    severity: "low"
    category: "configuration_management"

  - id: 2091
    connection_id: 2
    name: "aws_cloudwatch_advanced_alarm_conditions"
    description: "Verify CloudWatch alarms use appropriate threshold and evaluation settings"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 695  # SI-4 (System Monitoring)
    control_name: "SI-4"
    field_path: "alarms"
    resource_type: "AWSCloudWatchResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check alarm configuration sophistication
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no alarms
        else:
            result = True
            total_alarms = len(fetched_value)
            properly_configured_alarms = 0
            
            for alarm_name, alarm_data in fetched_value.items():
                # Check for reasonable alarm configuration
                has_actions = False
                if isinstance(alarm_data, dict):
                    alarm_actions = alarm_data.get('alarm_actions', [])
                    has_actions = len(alarm_actions) > 0
                else:
                    alarm_actions = getattr(alarm_data, 'alarm_actions', [])
                    has_actions = len(alarm_actions) > 0
                
                if has_actions:
                    properly_configured_alarms += 1
            
            # At least 80% of alarms should have actions configured
            if total_alarms > 0:
                configured_percentage = (properly_configured_alarms / total_alarms) * 100
                result = configured_percentage >= 80
    expected_value: null
    tags: ["security", "aws", "cloudwatch", "alarms", "thresholds"]
    severity: "medium"
    category: "system_information_integrity"

  - id: 2092
    connection_id: 2
    name: "aws_cloudtrail_advanced_event_selection"
    description: "Verify CloudTrail has comprehensive event selection configuration"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 96   # AU-2 (Event Logging)
    control_name: "AU-2"
    field_path: "trails"
    resource_type: "AWSCloudTrailResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check CloudTrail event selection comprehensiveness
        if not isinstance(fetched_value, dict):
            result = False  # Should have trails
        else:
            result = True
            comprehensive_trails = 0
            total_trails = len(fetched_value)
            
            for trail_name, trail_data in fetched_value.items():
                is_comprehensive = False
                if isinstance(trail_data, dict):
                    # Check if trail is logging (indicates comprehensive setup)
                    is_logging = trail_data.get('is_logging', False)
                    status = trail_data.get('status', {})
                    if is_logging or (status and status.get('is_logging', False)):
                        is_comprehensive = True
                else:
                    is_logging = getattr(trail_data, 'is_logging', False)
                    if is_logging:
                        is_comprehensive = True
                
                if is_comprehensive:
                    comprehensive_trails += 1
            
            # At least 50% of trails should be comprehensive
            if total_trails > 0:
                comprehensive_percentage = (comprehensive_trails / total_trails) * 100
                result = comprehensive_percentage >= 50
    expected_value: null
    tags: ["security", "aws", "cloudtrail", "event_selection", "comprehensive"]
    severity: "high"
    category: "audit_accountability"

  - id: 2093
    connection_id: 2
    name: "aws_multi_service_security_posture"
    description: "Verify coordinated security posture across multiple AWS services"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 75   # AC-3 (Access Enforcement)
    control_name: "AC-3"
    field_path: "instances"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Cross-service security posture assessment
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no instances
        else:
            result = True
            instances_with_comprehensive_security = 0
            total_instances = len(fetched_value)
            
            for instance_id, instance in fetched_value.items():
                security_features = 0
                
                # Check multiple security aspects
                if isinstance(instance, dict):
                    # Security groups
                    security_groups = instance.get('security_groups', [])
                    if len(security_groups) > 0:
                        security_features += 1
                    
                    # IAM instance profile
                    iam_profile = instance.get('iam_instance_profile')
                    if iam_profile:
                        security_features += 1
                    
                    # EBS optimization (performance security)
                    ebs_optimized = instance.get('ebs_optimized', False)
                    if ebs_optimized:
                        security_features += 1
                
                # Instance should have multiple security features
                if security_features >= 2:
                    instances_with_comprehensive_security += 1
            
            # At least 60% should have comprehensive security
            if total_instances > 0:
                security_percentage = (instances_with_comprehensive_security / total_instances) * 100
                result = security_percentage >= 60
    expected_value: null
    tags: ["security", "aws", "multi_service", "comprehensive", "posture"]
    severity: "high"
    category: "access_control"

  # GitHub Advanced Security & DevOps Intelligence (2094-2101)
  - id: 2094
    connection_id: 1
    name: "github_security_alert_response_maturity"
    description: "Verify mature security alert response and remediation practices"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 549  # IR-4 (Incident Handling)
    control_name: "IR-4"
    field_path: "security_data.total_dependabot_alerts"
    resource_type: "GithubResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check security alert management maturity
        if not isinstance(fetched_value, int):
            result = True  # Pass if no data
        else:
            dependabot_alerts = fetched_value
            # Mature organizations should have very few outstanding alerts
            result = dependabot_alerts <= 5  # Max 5 outstanding alerts
    expected_value: null
    tags: ["security", "github", "alerts", "incident_response", "maturity"]
    severity: "high"
    category: "incident_response"

  - id: 2095
    connection_id: 1
    name: "github_code_quality_automation"
    description: "Verify automated code quality and security scanning integration"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 679  # SI-2 (Flaw Remediation)
    control_name: "SI-2"
    field_path: "security_data.total_code_scanning_alerts"
    resource_type: "GithubResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check code scanning effectiveness
        if not isinstance(fetched_value, int):
            result = True  # Pass if no data
        else:
            code_scanning_alerts = fetched_value
            # Should have minimal unresolved code scanning alerts
            result = code_scanning_alerts <= 10  # Max 10 outstanding alerts
    expected_value: null
    tags: ["security", "github", "code_scanning", "quality", "automation"]
    severity: "medium"
    category: "system_information_integrity"

  - id: 2096
    connection_id: 1
    name: "github_branch_protection_comprehensiveness"
    description: "Verify comprehensive branch protection across all critical branches"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 275  # CM-3 (Configuration Change Control)
    control_name: "CM-3"
    field_path: "repository_data.branches"
    resource_type: "GithubResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check branch protection comprehensiveness
        if not isinstance(fetched_value, list):
            result = False
        else:
            protected_branches = 0
            total_branches = len(fetched_value)
            critical_branches_protected = 0
            
            for branch in fetched_value:
                is_protected = False
                branch_name = ''
                
                if isinstance(branch, dict):
                    is_protected = branch.get('protected', False)
                    branch_name = branch.get('name', '')
                else:
                    is_protected = getattr(branch, 'protected', False)
                    branch_name = getattr(branch, 'name', '')
                
                if is_protected:
                    protected_branches += 1
                    
                # Check critical branches
                if branch_name in ['main', 'master', 'production', 'prod', 'develop']:
                    if is_protected:
                        critical_branches_protected += 1
            
            # All critical branches should be protected, plus reasonable coverage
            critical_branch_count = sum(1 for branch in fetched_value 
                                      if (isinstance(branch, dict) and branch.get('name', '') in ['main', 'master', 'production', 'prod', 'develop']) or
                                         (hasattr(branch, 'name') and getattr(branch, 'name', '') in ['main', 'master', 'production', 'prod', 'develop']))
            
            result = (critical_branch_count == 0 or critical_branches_protected == critical_branch_count) and protected_branches >= 1
    expected_value: null
    tags: ["security", "github", "branch_protection", "comprehensive", "change_control"]
    severity: "high"
    category: "configuration_management"

  - id: 2097
    connection_id: 1
    name: "github_development_velocity_health"
    description: "Verify healthy development velocity and collaboration patterns"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 287  # CM-8 (System Component Inventory)
    control_name: "CM-8"
    field_path: "actions_data.recent_runs_count"
    resource_type: "GithubResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check development velocity health
        if not isinstance(fetched_value, int):
            result = True  # Pass if no data
        else:
            recent_runs = fetched_value
            # Healthy projects should have regular CI/CD activity
            result = recent_runs >= 5  # At least 5 recent workflow runs
    expected_value: null
    tags: ["governance", "github", "velocity", "development", "health"]
    severity: "low"
    category: "configuration_management"

  - id: 2098
    connection_id: 1
    name: "github_organization_security_standardization"
    description: "Verify organization-wide security standardization and policies"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 282  # CM-6 (Configuration Settings)
    control_name: "CM-6"
    field_path: "organization_data.admin_members"
    resource_type: "GithubResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check organization security standardization
        if not isinstance(fetched_value, int):
            result = True  # Pass if no data
        else:
            admin_members = fetched_value
            # Should have controlled admin access
            result = 1 <= admin_members <= 5  # Reasonable admin count
    expected_value: null
    tags: ["security", "github", "organization", "standardization", "policies"]
    severity: "medium"
    category: "configuration_management"

  - id: 2099
    connection_id: 1
    name: "github_supply_chain_security"
    description: "Verify supply chain security through dependency and workflow monitoring"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 773  # SA-9 (External System Services)
    control_name: "SA-9"
    field_path: "security_data.total_advisories"
    resource_type: "GithubResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check supply chain security awareness
        if not isinstance(fetched_value, int):
            result = True  # Pass if no data
        else:
            advisories = fetched_value
            # Should be monitoring for advisories but not have too many unaddressed
            result = advisories <= 15  # Max 15 advisory items
    expected_value: null
    tags: ["security", "github", "supply_chain", "dependencies", "advisories"]
    severity: "high"
    category: "system_services_acquisition"

  - id: 2100
    connection_id: 1
    name: "github_repository_maintenance_hygiene"
    description: "Verify good repository maintenance and hygiene practices"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 473  # MA-4 (Nonlocal Maintenance)
    control_name: "MA-4"
    field_path: "advanced_features_data.active_webhooks"
    resource_type: "GithubResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check maintenance hygiene
        if not isinstance(fetched_value, int):
            result = True  # Pass if no data
        else:
            active_webhooks = fetched_value
            # Should have some webhooks for automation but not excessive
            result = 0 <= active_webhooks <= 8  # Reasonable webhook count
    expected_value: null
    tags: ["governance", "github", "maintenance", "hygiene", "automation"]
    severity: "low"
    category: "maintenance"

  - id: 2101
    connection_id: 1
    name: "github_collaborative_development_maturity"
    description: "Verify mature collaborative development practices and governance"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 113  # AU-6 (Audit Record Review, Analysis, and Reporting)
    control_name: "AU-6"
    field_path: "repository_data.statistics.contributors_count"
    resource_type: "GithubResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check collaborative development maturity
        if not isinstance(fetched_value, int):
            result = True  # Pass if no data
        else:
            contributors = fetched_value
            # Should have reasonable contributor base for collaboration
            result = contributors >= 2  # At least 2 contributors for collaboration
    expected_value: null
    tags: ["governance", "github", "collaboration", "development", "maturity"]
    severity: "low"
    category: "audit_accountability"

  # Cross-Platform Intelligence & Advanced Analytics (2102-2105)  
  - id: 2102
    connection_id: 2
    name: "aws_cost_optimization_intelligence"
    description: "Verify intelligent cost optimization practices across AWS resources"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 287  # CM-8 (System Component Inventory)
    control_name: "CM-8"
    field_path: "instances"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check cost optimization intelligence
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no instances
        else:
            cost_optimized_instances = 0
            total_instances = len(fetched_value)
            
            for instance_id, instance in fetched_value.items():
                optimization_score = 0
                
                if isinstance(instance, dict):
                    # EBS optimization
                    if instance.get('ebs_optimized', False):
                        optimization_score += 1
                    
                    # Spot instance lifecycle (cost optimization)
                    if instance.get('instance_lifecycle') == 'spot':
                        optimization_score += 1
                    
                    # Proper instance type (not oversized)
                    instance_type = instance.get('instance_type', '')
                    if instance_type and not instance_type.startswith(('m5.4xlarge', 'm5.8xlarge')):
                        optimization_score += 1  # Reasonable sizing
                
                if optimization_score >= 2:
                    cost_optimized_instances += 1
            
            # At least 50% should show cost optimization
            if total_instances > 0:
                optimization_percentage = (cost_optimized_instances / total_instances) * 100
                result = optimization_percentage >= 50
    expected_value: null
    tags: ["governance", "aws", "cost_optimization", "intelligence", "efficiency"]
    severity: "medium"
    category: "configuration_management"

  - id: 2103
    connection_id: 2
    name: "aws_disaster_recovery_readiness"
    description: "Verify disaster recovery readiness across AWS infrastructure"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 277  # CP-9 (System Backup)
    control_name: "CP-9"
    field_path: "volumes"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check disaster recovery readiness
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no volumes
        else:
            backup_ready_volumes = 0
            total_volumes = len(fetched_value)
            
            for volume_id, volume in fetched_value.items():
                dr_score = 0
                
                if isinstance(volume, dict):
                    # Encryption (data protection)
                    if volume.get('encrypted', False):
                        dr_score += 1
                    
                    # Volume state (should be in-use or available)
                    state = volume.get('state', '')
                    if state in ['in-use', 'available']:
                        dr_score += 1
                
                if dr_score >= 2:
                    backup_ready_volumes += 1
            
            # At least 70% should be DR-ready
            if total_volumes > 0:
                dr_percentage = (backup_ready_volumes / total_volumes) * 100
                result = dr_percentage >= 70
    expected_value: null
    tags: ["security", "aws", "disaster_recovery", "backup", "readiness"]
    severity: "high"
    category: "contingency_planning"

  - id: 2104
    connection_id: 2
    name: "aws_compliance_automation_maturity"
    description: "Verify mature compliance automation and monitoring capabilities"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 695  # SI-4 (System Monitoring)
    control_name: "SI-4"
    field_path: "alarms"
    resource_type: "AWSCloudWatchResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check compliance automation maturity
        if not isinstance(fetched_value, dict):
            result = False  # Should have monitoring
        else:
            automated_alarms = 0
            total_alarms = len(fetched_value)
            
            for alarm_name, alarm_data in fetched_value.items():
                automation_indicators = 0
                
                if isinstance(alarm_data, dict):
                    # Alarm actions (automation)
                    alarm_actions = alarm_data.get('alarm_actions', [])
                    if len(alarm_actions) > 0:
                        automation_indicators += 1
                    
                    # Actions enabled
                    if alarm_data.get('actions_enabled', True):
                        automation_indicators += 1
                
                if automation_indicators >= 2:
                    automated_alarms += 1
            
            # At least 60% should be automated
            if total_alarms > 0:
                automation_percentage = (automated_alarms / total_alarms) * 100
                result = automation_percentage >= 60 and total_alarms >= 3
            else:
                result = False
    expected_value: null
    tags: ["governance", "aws", "compliance", "automation", "maturity"]
    severity: "high"
    category: "system_information_integrity"

  - id: 2105
    connection_id: 2
    name: "aws_operational_excellence_indicators"
    description: "Verify operational excellence through comprehensive AWS service utilization"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 282  # CM-6 (Configuration Settings)
    control_name: "CM-6"
    field_path: "dashboards"
    resource_type: "AWSCloudWatchResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check operational excellence indicators
        if not isinstance(fetched_value, dict):
            result = False  # Should have operational dashboards
        else:
            total_dashboards = len(fetched_value)
            operational_dashboards = 0
            
            for dashboard_name in fetched_value.keys():
                # Check for operational excellence indicators in naming
                operational_keywords = ['ops', 'operational', 'monitoring', 'health', 'performance', 'metrics']
                if any(keyword in dashboard_name.lower() for keyword in operational_keywords):
                    operational_dashboards += 1
            
            # Should have multiple operational dashboards
            result = total_dashboards >= 2 and operational_dashboards >= 1
    expected_value: null
    tags: ["governance", "aws", "operational_excellence", "monitoring", "best_practices"]
    severity: "medium"
    category: "configuration_management"