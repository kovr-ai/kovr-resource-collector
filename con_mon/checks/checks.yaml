# GitHub-specific checks configuration
# Maps to Check model structure in checks/models.py
# Updated to use framework_id and control_id from CSV data for better performance

checks:
  - id: 1001
    connection_id: 1
    name: "github_main_branch_protected"
    description: "Verify that the main branch in GitHub repository has protection enabled"
    framework_id: 3  # NIST 800-171 rev2 Catalog
    framework_name: "NIST 800-171 rev2 Catalog"
    control_id: 1240  # CM-3-4-3 (Configuration Change Control)
    control_name: "CM-3-4-3"
    resource_type: "GithubResource"
    field_path: "repository_data.branches"
    resource_type: "GithubResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if the main branch (or master branch) is protected
        if not isinstance(fetched_value, list):
            result = False
        else:
            result = False  # Default to False if main branch not found
            main_branch_names = ['main', 'master', 'production', 'prod']  # Common main branch names
            
            for branch in fetched_value:
                branch_name = None
                is_protected = False
                
                if isinstance(branch, dict):
                    branch_name = branch.get('name', '')
                    is_protected = branch.get('protected', False)
                else:
                    # Handle Pydantic models
                    branch_name = getattr(branch, 'name', '')
                    is_protected = getattr(branch, 'protected', False)
                
                # Check if this is a main branch
                if branch_name in main_branch_names:
                    result = is_protected
                    break  # Found main branch, stop looking
    expected_value: null
    tags: ["security", "github", "branch_protection", "main_branch"]
    severity: "high"
    category: "access_control"

  - id: 1002
    connection_id: 1
    name: "github_repository_private"
    description: "Verify that GitHub repository is private"
    framework_id: 3  # NIST 800-171 rev2 Catalog
    framework_name: "NIST 800-171 rev2 Catalog"
    control_id: 1217  # AC-3-1-18 (Access Control for Mobile Devices)
    control_name: "AC-3-1-18"
    resource_type: "GithubResource"
    field_path: "repository_data.basic_info.private"
    resource_type: "GithubResource"
    operation:
      name: "EQUAL"
    expected_value: true
    tags: ["security", "github", "visibility"]
    severity: "medium"
    category: "access_control"

  - id: 1003
    connection_id: 1
    name: "github_minimum_branch_count"
    description: "Verify that GitHub repository has at least 3 branches"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 287  # CM-8 (System Component Inventory)
    control_name: "CM-8"
    resource_type: "GithubResource"
    field_path: "len(repository_data.branches)"
    resource_type: "GithubResource"
    operation:
      name: "GREATER_THAN_OR_EQUAL"
    expected_value: 3
    tags: ["development", "github", "branch_management"]
    severity: "low"
    category: "development_practices"

  # NIST 800-171 Rev 2 - Additional Security Controls
  - id: 1004
    connection_id: 1
    name: "github_advanced_security_enabled"
    description: "Verify that GitHub Advanced Security is enabled"
    framework_id: 3  # NIST 800-171 rev2 Catalog
    framework_name: "NIST 800-171 rev2 Catalog"
    control_id: 1303  # SI-3-14-1 (Flaw Remediation)
    control_name: "SI-3-14-1"
    resource_type: "GithubResource"
    field_path: "security_data.security_analysis.advanced_security_enabled"
    resource_type: "GithubResource"
    operation:
      name: "EQUAL"
    expected_value: true
    tags: ["security", "github", "advanced_security"]
    severity: "high"
    category: "security_assessment"

  - id: 1005
    connection_id: 1
    name: "github_secret_scanning_enabled"
    description: "Verify that secret scanning is enabled to protect authentication info"
    framework_id: 3  # NIST 800-171 rev2 Catalog
    framework_name: "NIST 800-171 rev2 Catalog"
    control_id: 1255  # IA-3-5-9 (Password Management)
    control_name: "IA-3-5-9"
    resource_type: "GithubResource"
    field_path: "security_data.security_analysis.secret_scanning_enabled"
    resource_type: "GithubResource"
    operation:
      name: "EQUAL"
    expected_value: true
    tags: ["security", "github", "secret_scanning"]
    severity: "high"
    category: "identity_authentication"

  - id: 1006
    connection_id: 1
    name: "github_push_protection_enabled"
    description: "Verify that push protection is enabled to prevent secret leaks"
    framework_id: 3  # NIST 800-171 rev2 Catalog
    framework_name: "NIST 800-171 rev2 Catalog"
    control_id: 1255  # IA-3-5-9 (Password Management)
    control_name: "IA-3-5-9"
    resource_type: "GithubResource"
    field_path: "security_data.security_analysis.push_protection_enabled"
    resource_type: "GithubResource"
    operation:
      name: "EQUAL"
    expected_value: true
    tags: ["security", "github", "push_protection"]
    severity: "high"
    category: "identity_authentication"

  - id: 1007
    connection_id: 1
    name: "github_dependency_review_enabled"
    description: "Verify that dependency review is enabled for vulnerability management"
    framework_id: 3  # NIST 800-171 rev2 Catalog
    framework_name: "NIST 800-171 rev2 Catalog"
    control_id: 1303  # SI-3-14-1 (Flaw Remediation)
    control_name: "SI-3-14-1"
    resource_type: "GithubResource"
    field_path: "security_data.security_analysis.dependency_review_enabled"
    resource_type: "GithubResource"
    operation:
      name: "EQUAL"
    expected_value: true
    tags: ["security", "github", "dependency_review"]
    severity: "medium"
    category: "security_assessment"

  - id: 1008
    connection_id: 1
    name: "github_no_dependabot_alerts"
    description: "Verify that there are no unresolved Dependabot security alerts"
    framework_id: 3  # NIST 800-171 rev2 Catalog
    framework_name: "NIST 800-171 rev2 Catalog"
    control_id: 1303  # SI-3-14-1 (Flaw Remediation)
    control_name: "SI-3-14-1"
    resource_type: "GithubResource"
    field_path: "security_data.total_dependabot_alerts"
    resource_type: "GithubResource"
    operation:
      name: "EQUAL"
    expected_value: 0
    tags: ["security", "github", "dependabot", "vulnerability"]
    severity: "medium"
    category: "security_assessment"

  - id: 1009
    connection_id: 1
    name: "github_no_code_scanning_alerts"
    description: "Verify that there are no unresolved code scanning alerts"  
    framework_id: 3  # NIST 800-171 rev2 Catalog
    framework_name: "NIST 800-171 rev2 Catalog"
    control_id: 1303  # SI-3-14-1 (Flaw Remediation)
    control_name: "SI-3-14-1"
    resource_type: "GithubResource"
    field_path: "security_data.total_code_scanning_alerts"
    resource_type: "GithubResource"
    operation:
      name: "EQUAL"
    expected_value: 0
    tags: ["security", "github", "code_scanning", "sast"]
    severity: "medium"
    category: "security_assessment"

  - id: 1010
    connection_id: 1
    name: "github_external_collaborators_limited"
    description: "Verify that external collaborators are limited for access control"
    framework_id: 3  # NIST 800-171 rev2 Catalog
    framework_name: "NIST 800-171 rev2 Catalog"
    control_id: 1205  # AC-3-1-6 (Least Privilege â€“ Privileged Accounts)
    control_name: "AC-3-1-6"
    resource_type: "GithubResource"
    field_path: "organization_data.total_outside_collaborators"
    resource_type: "GithubResource"
    operation:
      name: "LESS_THAN_OR_EQUAL"
    expected_value: 5
    tags: ["security", "github", "access_control", "collaborators"]
    severity: "medium"
    category: "access_control"

  - id: 1011
    connection_id: 1
    name: "github_repository_not_archived"
    description: "Verify that active repositories are not archived"
    framework_id: 3  # NIST 800-171 rev2 Catalog
    framework_name: "NIST 800-171 rev2 Catalog"
    control_id: 1200  # AC-3-1-1 (Account Management)
    control_name: "AC-3-1-1"
    resource_type: "GithubResource"
    field_path: "repository_data.basic_info.archived"
    operation:
      name: "EQUAL"
    expected_value: false
    tags: ["governance", "github", "repository_status"]
    severity: "low"
    category: "access_control"

  - id: 1012
    connection_id: 1
    name: "github_repository_not_disabled"
    description: "Verify that repositories are not disabled"
    framework_id: 3  # NIST 800-171 rev2 Catalog
    framework_name: "NIST 800-171 rev2 Catalog"
    control_id: 1200  # AC-3-1-1 (Account Management)
    control_name: "AC-3-1-1"
    resource_type: "GithubResource"
    field_path: "repository_data.basic_info.disabled"
    operation:
      name: "EQUAL"
    expected_value: false
    tags: ["governance", "github", "repository_status"]
    severity: "medium"
    category: "access_control"

  # NIST 800-53 Rev 5 - Additional Controls
  - id: 1013
    connection_id: 1
    name: "github_admin_members_limited"
    description: "Verify that admin privileges are limited (Least Privilege)"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 90   # AC-6 (Least Privilege)
    control_name: "AC-6"
    resource_type: "GithubResource"
    field_path: "organization_data.admin_members"
    operation:
      name: "LESS_THAN_OR_EQUAL"
    expected_value: 3
    tags: ["security", "github", "access_control", "least_privilege"]
    severity: "high"
    category: "access_control"

  - id: 1014
    connection_id: 1
    name: "github_has_security_features"
    description: "Verify that multiple security features are enabled"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 75   # AC-3 (Access Enforcement)
    control_name: "AC-3"
    resource_type: "GithubResource"
    field_path: "security_data.security_features_enabled"
    operation:
      name: "GREATER_THAN_OR_EQUAL"
    expected_value: 2
    tags: ["security", "github", "security_features"]
    severity: "high"
    category: "access_control"

  - id: 1015
    connection_id: 1
    name: "github_webhooks_secured"
    description: "Verify that webhooks are properly configured and limited"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 473  # MA-4 (Nonlocal Maintenance)
    control_name: "MA-4"
    resource_type: "GithubResource"
    field_path: "advanced_features_data.total_webhooks"
    operation:
      name: "LESS_THAN_OR_EQUAL"
    expected_value: 5
    tags: ["security", "github", "webhooks", "integrations"]
    severity: "medium"
    category: "maintenance"

  - id: 1016
    connection_id: 1
    name: "github_active_webhooks_monitored"
    description: "Verify that active webhooks are monitored"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 695  # SI-4 (System Monitoring)
    control_name: "SI-4"
    resource_type: "GithubResource"
    field_path: "advanced_features_data.active_webhooks"
    operation:
      name: "LESS_THAN_OR_EQUAL"
    expected_value: 3
    tags: ["security", "github", "monitoring", "webhooks"]
    severity: "medium"
    category: "system_monitoring"

  - id: 1017
    connection_id: 1
    name: "github_recent_activity"
    description: "Verify that repository shows recent development activity"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 287  # CM-8 (System Component Inventory)
    control_name: "CM-8"
    resource_type: "GithubResource"
    field_path: "repository_data.statistics.total_commits"
    operation:
      name: "GREATER_THAN"
    expected_value: 10
    tags: ["development", "github", "activity", "inventory"]
    severity: "low"
    category: "configuration_management"

  - id: 1018
    connection_id: 1
    name: "github_contributors_managed"
    description: "Verify that repository has appropriate number of contributors"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 71   # AC-2 (Account Management)
    control_name: "AC-2"
    resource_type: "GithubResource"
    field_path: "repository_data.statistics.contributors_count"
    operation:
      name: "GREATER_THAN"
    expected_value: 1
    tags: ["governance", "github", "contributors", "account_management"]
    severity: "low"
    category: "access_control"

  - id: 1019
    connection_id: 1
    name: "github_issues_enabled"
    description: "Verify that issues are enabled for incident tracking"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 549  # IR-4 (Incident Handling)
    control_name: "IR-4"
    resource_type: "GithubResource"
    field_path: "repository_data.metadata.has_issues"
    operation:
      name: "EQUAL"
    expected_value: true
    tags: ["governance", "github", "issues", "incident_response"]
    severity: "low"
    category: "incident_response"

  - id: 1020
    connection_id: 1
    name: "github_template_usage_controlled"
    description: "Verify that template repositories are appropriately configured"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 282  # CM-6 (Configuration Settings)
    control_name: "CM-6"
    resource_type: "GithubResource"
    field_path: "repository_data.metadata.is_template"
    operation:
      name: "EQUAL"
    expected_value: false
    tags: ["governance", "github", "templates", "least_functionality"]
    severity: "low"
    category: "configuration_management"

  - id: 1021
    connection_id: 1
    name: "github_collaborators_monitored"
    description: "Verify that total collaborators are within acceptable limits"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 113  # AU-6 (Audit Record Review, Analysis, and Reporting)
    control_name: "AU-6"
    resource_type: "GithubResource"
    field_path: "collaboration_data.total_collaborators"
    operation:
      name: "LESS_THAN_OR_EQUAL"
    expected_value: 20
    tags: ["security", "github", "collaborators", "audit_review"]
    severity: "medium"
    category: "audit_accountability"

  - id: 1022
    connection_id: 1
    name: "github_open_issues_managed"
    description: "Verify that open issues are actively managed"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 549  # IR-4 (Incident Handling)
    control_name: "IR-4"
    resource_type: "GithubResource"
    field_path: "collaboration_data.open_issues"
    operation:
      name: "LESS_THAN_OR_EQUAL"
    expected_value: 50
    tags: ["governance", "github", "issues", "incident_handling"]
    severity: "low"
    category: "incident_response"

  - id: 1023
    connection_id: 1
    name: "github_pull_requests_active"
    description: "Verify that pull requests indicate active development"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 275  # CM-3 (Configuration Change Control)
    control_name: "CM-3"
    resource_type: "GithubResource"
    field_path: "collaboration_data.total_pull_requests"
    operation:
      name: "GREATER_THAN"
    expected_value: 5
    tags: ["development", "github", "pull_requests", "change_control"]
    severity: "low"
    category: "configuration_management"

  - id: 1024
    connection_id: 1
    name: "github_security_advisories_monitored"
    description: "Verify that security advisories are being tracked"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 96   # AU-2 (Event Logging)
    control_name: "AU-2"
    resource_type: "GithubResource"
    field_path: "security_data.total_advisories"
    operation:
      name: "GREATER_THAN_OR_EQUAL"
    expected_value: 0
    tags: ["security", "github", "advisories", "audit_events"]
    severity: "medium"
    category: "audit_accountability"

  - id: 1025
    connection_id: 1
    name: "github_workflows_controlled"
    description: "Verify that GitHub Actions workflows are controlled and limited"
    framework_id: 3  # NIST 800-171 rev2 Catalog
    framework_name: "NIST 800-171 rev2 Catalog"
    control_id: 1201  # AC-3-1-2 (Access Enforcement)
    control_name: "AC-3-1-2"
    resource_type: "GithubResource"
    field_path: "actions_data.total_workflows"
    operation:
      name: "LESS_THAN_OR_EQUAL"
    expected_value: 10
    tags: ["security", "github", "workflows", "process_control"]
    severity: "medium"
    category: "access_control"

  - id: 1026
    connection_id: 1
    name: "github_active_workflows_monitored"
    description: "Verify that active workflows are monitored for security"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 773  # SA-9 (External System Services)
    control_name: "SA-9"
    resource_type: "GithubResource"
    field_path: "actions_data.active_workflows"
    operation:
      name: "LESS_THAN_OR_EQUAL"
    expected_value: 5
    tags: ["security", "github", "workflows", "external_software"]
    severity: "medium"
    category: "system_services_acquisition"

  - id: 1027
    connection_id: 1
    name: "github_recent_workflow_activity"
    description: "Verify that workflow runs indicate active CI/CD"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 779  # SA-11 (Developer Security and Privacy Architecture and Design Testing)
    control_name: "SA-11"
    resource_type: "GithubResource"
    field_path: "actions_data.recent_runs_count"
    operation:
      name: "GREATER_THAN"
    expected_value: 3
    tags: ["development", "github", "cicd", "security_testing"]
    severity: "low"
    category: "system_services_acquisition"

  - id: 1028
    connection_id: 1
    name: "github_organization_members_controlled"
    description: "Verify that organization membership is controlled"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 71   # AC-2 (Account Management)
    control_name: "AC-2"
    resource_type: "GithubResource"
    field_path: "organization_data.total_members"
    operation:
      name: "GREATER_THAN"
    expected_value: 1
    tags: ["security", "github", "organization", "account_management"]
    severity: "medium"
    category: "access_control"

  - id: 1029
    connection_id: 1
    name: "github_teams_structured"
    description: "Verify that teams are used for structured access control"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 75   # AC-3 (Access Enforcement)
    control_name: "AC-3"
    resource_type: "GithubResource"
    field_path: "organization_data.total_teams"
    operation:
      name: "GREATER_THAN"
    expected_value: 0
    tags: ["security", "github", "teams", "access_enforcement"]
    severity: "low"
    category: "access_control"

  - id: 1030
    connection_id: 1
    name: "github_repository_has_license"
    description: "Verify that repository has a defined license for compliance"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 595  # PM-1 (Program Management Policy and Procedures)
    control_name: "PM-1"
    resource_type: "GithubResource"
    field_path: "repository_data.metadata.license"
    operation:
      name: "NOT_EQUAL"  
    expected_value: null
    tags: ["governance", "github", "license", "program_management"]
    severity: "low"
    category: "program_management"

  # AWS Resource Checks (Original 5)
  - id: 2001
    connection_id: 2
    name: "aws_ec2_security_groups_no_open_ingress"
    description: "Verify that EC2 security groups do not allow unrestricted ingress from 0.0.0.0/0"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 75   # AC-3 (Access Enforcement)
    control_name: "AC-3"
    field_path: "security_groups"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if any security group has unrestricted ingress rules
        if not isinstance(fetched_value, dict):
            result = True  # Default to pass if no security groups
        else:
            result = True  # Default to pass
            for sg_id, sg in fetched_value.items():
                if isinstance(sg, dict):
                    ingress_rules = sg.get('inbound_rules', [])
                else:
                    # Handle Pydantic models
                    ingress_rules = getattr(sg, 'inbound_rules', [])
                
                for rule in ingress_rules:
                    cidr_blocks = rule.get('cidr_blocks', []) if isinstance(rule, dict) else getattr(rule, 'cidr_blocks', [])
                    if '0.0.0.0/0' in cidr_blocks:
                        result = False
                        break
                if not result:
                    break
    expected_value: null
    tags: ["security", "aws", "ec2", "security_groups", "network_access"]
    severity: "high"
    category: "access_control"

  - id: 2002
    connection_id: 2
    name: "aws_iam_users_have_mfa"
    description: "Verify that IAM users have multi-factor authentication enabled"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 157  # IA-2 (Identification and Authentication)
    control_name: "IA-2"
    field_path: "users"
    resource_type: "AWSIAMResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if all IAM users have MFA enabled
        if not isinstance(fetched_value, dict) or len(fetched_value) == 0:
            result = True  # Pass if no users
        else:
            result = True
            for user_name, user in fetched_value.items():
                if isinstance(user, dict):
                    mfa_devices = user.get('mfa_devices', [])
                else:
                    # Handle Pydantic models
                    mfa_devices = getattr(user, 'mfa_devices', [])
                
                if len(mfa_devices) == 0:
                    result = False
                    break
    expected_value: null
    tags: ["security", "aws", "iam", "mfa", "authentication"]
    severity: "high"
    category: "identification_authentication"

  - id: 2003
    connection_id: 2
    name: "aws_s3_buckets_encrypted"
    description: "Verify that all S3 buckets have encryption enabled"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 658  # SC-8 (Transmission Confidentiality and Integrity)
    control_name: "SC-8"
    field_path: "buckets"
    resource_type: "AWSS3Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if all S3 buckets have encryption enabled
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no buckets
        else:
            result = True
            for bucket_name, bucket in fetched_value.items():
                if isinstance(bucket, dict):
                    encryption = bucket.get('encryption', {})
                else:
                    # Handle Pydantic models
                    encryption = getattr(bucket, 'encryption', {})
                
                if not encryption or not encryption.get('enabled', False):
                    result = False
                    break
    expected_value: null
    tags: ["security", "aws", "s3", "encryption", "data_protection"]
    severity: "high"
    category: "system_communications_protection"

  - id: 2004
    connection_id: 2
    name: "aws_cloudtrail_logging_enabled"
    description: "Verify that CloudTrail logging is enabled for audit trails"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 96   # AU-2 (Event Logging)
    control_name: "AU-2"
    field_path: "trails"
    resource_type: "AWSCloudTrailResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if at least one CloudTrail is enabled and logging
        if not isinstance(fetched_value, dict):
            result = False  # Fail if no trails
        else:
            result = False
            for trail_name, trail in fetched_value.items():
                if isinstance(trail, dict):
                    is_logging = trail.get('is_logging', False)
                    status = trail.get('status', {})
                else:
                    # Handle Pydantic models
                    is_logging = getattr(trail, 'is_logging', False)
                    status = getattr(trail, 'status', {})
                    
                if is_logging and status.get('is_logging', False):
                    result = True
                    break
    expected_value: null
    tags: ["security", "aws", "cloudtrail", "logging", "audit"]
    severity: "high"
    category: "audit_accountability"

  - id: 2005
    connection_id: 2
    name: "aws_cloudwatch_log_groups_exist"
    description: "Verify that CloudWatch log groups exist for monitoring"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 695  # SI-4 (System Monitoring)
    control_name: "SI-4"
    field_path: "log_groups"
    resource_type: "AWSCloudWatchResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if CloudWatch log groups exist for monitoring
        if not isinstance(fetched_value, dict):
            result = False  # Fail if no log groups
        else:
            result = len(fetched_value) > 0  # Pass if at least one log group exists
    expected_value: null
    tags: ["security", "aws", "cloudwatch", "monitoring", "logging"]
    severity: "medium"
    category: "system_information_integrity"

  # VPC Security Checks (2006-2013)
  - id: 2006
    connection_id: 2
    name: "aws_vpc_flow_logs_enabled"
    description: "Verify that VPC flow logs are enabled for network monitoring"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 695  # SI-4 (System Monitoring)
    control_name: "SI-4"
    field_path: "vpcs"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if VPCs have flow logs enabled
        if not isinstance(fetched_value, dict):
            result = False
        else:
            result = True
            for vpc_id, vpc in fetched_value.items():
                flow_logs_enabled = False
                if isinstance(vpc, dict):
                    flow_logs_enabled = vpc.get('flow_logs_enabled', False)
                else:
                    flow_logs_enabled = getattr(vpc, 'flow_logs_enabled', False)
                
                if not flow_logs_enabled:
                    result = False
                    break
    expected_value: null
    tags: ["security", "aws", "vpc", "flow_logs", "monitoring"]
    severity: "high"
    category: "system_information_integrity"

  - id: 2007
    connection_id: 2
    name: "aws_vpc_no_default_vpc_usage"
    description: "Verify that default VPC is not used for production workloads"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 75   # AC-3 (Access Enforcement)
    control_name: "AC-3"
    field_path: "vpcs"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if default VPC is being used
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no VPCs
        else:
            result = True
            for vpc_id, vpc in fetched_value.items():
                is_default = False
                if isinstance(vpc, dict):
                    is_default = vpc.get('is_default', False)
                else:
                    is_default = getattr(vpc, 'is_default', False)
                
                if is_default:
                    result = False
                    break
    expected_value: null
    tags: ["security", "aws", "vpc", "default_vpc", "network"]
    severity: "medium"
    category: "access_control"

  - id: 2008
    connection_id: 2
    name: "aws_subnets_multi_az_deployment"
    description: "Verify that subnets are deployed across multiple availability zones"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 277  # CP-9 (System Backup)
    control_name: "CP-9"
    field_path: "subnets"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if subnets span multiple AZs
        if not isinstance(fetched_value, dict):
            result = False
        else:
            availability_zones = set()
            for subnet_id, subnet in fetched_value.items():
                az = None
                if isinstance(subnet, dict):
                    az = subnet.get('availability_zone')
                else:
                    az = getattr(subnet, 'availability_zone', None)
                
                if az:
                    availability_zones.add(az)
            
            result = len(availability_zones) >= 2  # At least 2 AZs
    expected_value: null
    tags: ["security", "aws", "subnet", "multi_az", "availability"]
    severity: "medium"
    category: "contingency_planning"

  - id: 2009
    connection_id: 2
    name: "aws_nat_gateways_deployed"
    description: "Verify that NAT gateways are deployed for private subnet internet access"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 658  # SC-8 (Transmission Confidentiality and Integrity)
    control_name: "SC-8"
    field_path: "nat_gateways"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if NAT gateways exist for private subnets
        if not isinstance(fetched_value, dict):
            result = False
        else:
            active_nat_gateways = 0
            for nat_gw_id, nat_gw in fetched_value.items():
                state = None
                if isinstance(nat_gw, dict):
                    state = nat_gw.get('state')
                else:
                    state = getattr(nat_gw, 'state', None)
                
                if state == 'available':
                    active_nat_gateways += 1
            
            result = active_nat_gateways > 0
    expected_value: null
    tags: ["security", "aws", "nat_gateway", "private_subnet", "network"]
    severity: "medium"
    category: "system_communications_protection"

  - id: 2010
    connection_id: 2
    name: "aws_route_tables_secured"
    description: "Verify that route tables have secure routing configurations"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 75   # AC-3 (Access Enforcement)
    control_name: "AC-3"
    field_path: "route_tables"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if route tables don't have overly permissive routes
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no route tables
        else:
            result = True
            for rt_id, rt in fetched_value.items():
                routes = []
                if isinstance(rt, dict):
                    routes = rt.get('routes', [])
                else:
                    routes = getattr(rt, 'routes', [])
                
                for route in routes:
                    destination = route.get('destination_cidr_block', '') if isinstance(route, dict) else getattr(route, 'destination_cidr_block', '')
                    if destination == '0.0.0.0/0':
                        # Check if it's going to an internet gateway (acceptable) or something else (risky)
                        gateway_id = route.get('gateway_id', '') if isinstance(route, dict) else getattr(route, 'gateway_id', '')
                        if not gateway_id.startswith('igw-'):
                            result = False
                            break
                if not result:
                    break
    expected_value: null
    tags: ["security", "aws", "route_table", "routing", "network"]
    severity: "high"
    category: "access_control"

  # EBS Security Checks (2011-2014)
  - id: 2011
    connection_id: 2
    name: "aws_ebs_volumes_encrypted"
    description: "Verify that EBS volumes are encrypted at rest"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 658  # SC-8 (Transmission Confidentiality and Integrity)
    control_name: "SC-8"
    field_path: "volumes"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if all EBS volumes are encrypted
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no volumes
        else:
            result = True
            for volume_id, volume in fetched_value.items():
                encrypted = False
                if isinstance(volume, dict):
                    encrypted = volume.get('encrypted', False)
                else:
                    encrypted = getattr(volume, 'encrypted', False)
                
                if not encrypted:
                    result = False
                    break
    expected_value: null
    tags: ["security", "aws", "ebs", "encryption", "storage"]
    severity: "high"
    category: "system_communications_protection"

  - id: 2012
    connection_id: 2
    name: "aws_ebs_snapshots_not_public"
    description: "Verify that EBS snapshots are not publicly accessible"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 75   # AC-3 (Access Enforcement)
    control_name: "AC-3"
    field_path: "snapshots"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if EBS snapshots are private
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no snapshots
        else:
            result = True
            for snapshot_id, snapshot in fetched_value.items():
                is_public = False
                if isinstance(snapshot, dict):
                    # Check for public permissions
                    permissions = snapshot.get('create_volume_permissions', [])
                    for perm in permissions:
                        if perm.get('Group') == 'all':
                            is_public = True
                            break
                else:
                    permissions = getattr(snapshot, 'create_volume_permissions', [])
                    for perm in permissions:
                        if getattr(perm, 'Group', None) == 'all':
                            is_public = True
                            break
                
                if is_public:
                    result = False
                    break
    expected_value: null
    tags: ["security", "aws", "ebs", "snapshot", "public_access"]
    severity: "high"
    category: "access_control"

  - id: 2013
    connection_id: 2
    name: "aws_ebs_volumes_have_backups"
    description: "Verify that EBS volumes have recent snapshots for backup"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 277  # CP-9 (System Backup)
    control_name: "CP-9"
    field_path: "volumes"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if EBS volumes have recent snapshots
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no volumes
        else:
            result = True
            # Note: This is a simplified check - in real implementation, 
            # we'd cross-reference with snapshots to verify backup recency
            for volume_id, volume in fetched_value.items():
                # For now, assume volumes in 'in-use' state are backed up
                state = None
                if isinstance(volume, dict):
                    state = volume.get('state')
                else:
                    state = getattr(volume, 'state', None)
                
                # This is a placeholder - real check would verify snapshot existence and recency
                if state not in ['in-use', 'available']:
                    result = False
                    break
    expected_value: null
    tags: ["security", "aws", "ebs", "backup", "disaster_recovery"]
    severity: "medium"
    category: "contingency_planning"

  # Enhanced S3 Security Checks (2014-2017)
  - id: 2014
    connection_id: 2
    name: "aws_s3_versioning_enabled"
    description: "Verify that S3 bucket versioning is enabled for data protection"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 277  # CP-9 (System Backup)
    control_name: "CP-9"
    field_path: "bucket_versioning"
    resource_type: "AWSS3Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if S3 bucket versioning is enabled
        if not isinstance(fetched_value, dict):
            result = False
        else:
            result = True
            for bucket_name, versioning_config in fetched_value.items():
                status = None
                if isinstance(versioning_config, dict):
                    status = versioning_config.get('Status')
                else:
                    status = getattr(versioning_config, 'Status', None)
                
                if status != 'Enabled':
                    result = False
                    break
    expected_value: null
    tags: ["security", "aws", "s3", "versioning", "data_protection"]
    severity: "medium"
    category: "contingency_planning"

  - id: 2015
    connection_id: 2
    name: "aws_s3_access_logging_enabled"
    description: "Verify that S3 bucket access logging is enabled for audit trails"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 96   # AU-2 (Event Logging)
    control_name: "AU-2"
    field_path: "bucket_logging"
    resource_type: "AWSS3Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if S3 bucket access logging is enabled
        if not isinstance(fetched_value, dict):
            result = False
        else:
            result = True
            for bucket_name, logging_config in fetched_value.items():
                # Check if logging is configured
                logging_enabled = False
                if isinstance(logging_config, dict):
                    logging_enabled = 'LoggingEnabled' in logging_config
                else:
                    logging_enabled = hasattr(logging_config, 'LoggingEnabled')
                
                if not logging_enabled:
                    result = False
                    break
    expected_value: null
    tags: ["security", "aws", "s3", "access_logging", "audit"]
    severity: "medium"
    category: "audit_accountability"

  - id: 2016
    connection_id: 2
    name: "aws_s3_public_access_blocked"
    description: "Verify that S3 bucket public access is blocked at bucket level"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 75   # AC-3 (Access Enforcement)
    control_name: "AC-3"
    field_path: "bucket_public_access"
    resource_type: "AWSS3Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if S3 bucket public access is blocked
        if not isinstance(fetched_value, dict):
            result = False
        else:
            result = True
            for bucket_name, public_access_config in fetched_value.items():
                if isinstance(public_access_config, dict):
                    block_public_acls = public_access_config.get('BlockPublicAcls', False)
                    ignore_public_acls = public_access_config.get('IgnorePublicAcls', False)
                    block_public_policy = public_access_config.get('BlockPublicPolicy', False)
                    restrict_public_buckets = public_access_config.get('RestrictPublicBuckets', False)
                else:
                    block_public_acls = getattr(public_access_config, 'BlockPublicAcls', False)
                    ignore_public_acls = getattr(public_access_config, 'IgnorePublicAcls', False)
                    block_public_policy = getattr(public_access_config, 'BlockPublicPolicy', False)
                    restrict_public_buckets = getattr(public_access_config, 'RestrictPublicBuckets', False)
                
                if not (block_public_acls and ignore_public_acls and block_public_policy and restrict_public_buckets):
                    result = False
                    break
    expected_value: null
    tags: ["security", "aws", "s3", "public_access", "data_protection"]
    severity: "high"
    category: "access_control"

  - id: 2017
    connection_id: 2
    name: "aws_s3_lifecycle_policies_configured"
    description: "Verify that S3 buckets have lifecycle policies for cost optimization"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 282  # CM-6 (Configuration Settings)
    control_name: "CM-6"
    field_path: "bucket_lifecycle"
    resource_type: "AWSS3Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if S3 buckets have lifecycle policies configured
        if not isinstance(fetched_value, dict):
            result = False
        else:
            result = True
            for bucket_name, lifecycle_config in fetched_value.items():
                has_rules = False
                if isinstance(lifecycle_config, dict):
                    rules = lifecycle_config.get('Rules', [])
                    has_rules = len(rules) > 0
                else:
                    rules = getattr(lifecycle_config, 'Rules', [])
                    has_rules = len(rules) > 0
                
                if not has_rules:
                    result = False
                    break
    expected_value: null
    tags: ["security", "aws", "s3", "lifecycle", "cost_optimization"]
    severity: "low"
    category: "configuration_management"

  # Enhanced IAM Security Checks (2018-2021)
  - id: 2018
    connection_id: 2
    name: "aws_iam_roles_have_trust_policies"
    description: "Verify that IAM roles have properly configured trust policies"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 157  # IA-2 (Identification and Authentication)
    control_name: "IA-2"
    field_path: "roles"
    resource_type: "AWSIAMResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if IAM roles have trust policies
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no roles
        else:
            result = True
            for role_name, role_data in fetched_value.items():
                trust_policy = None
                if isinstance(role_data, dict):
                    trust_policy = role_data.get('assume_role_policy_document')
                else:
                    trust_policy = getattr(role_data, 'assume_role_policy_document', None)
                
                if not trust_policy:
                    result = False
                    break
    expected_value: null
    tags: ["security", "aws", "iam", "roles", "trust_policy"]
    severity: "high"
    category: "identification_authentication"

  - id: 2019
    connection_id: 2
    name: "aws_iam_policies_least_privilege"
    description: "Verify that IAM policies follow least privilege principle"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 90   # AC-6 (Least Privilege)
    control_name: "AC-6"
    field_path: "policies"
    resource_type: "AWSIAMResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if IAM policies avoid overly broad permissions
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no policies
        else:
            result = True
            for policy_name, policy_data in fetched_value.items():
                # This is a simplified check - look for wildcard actions/resources
                policy_doc = None
                if isinstance(policy_data, dict):
                    policy_doc = policy_data.get('policy_document', {})
                else:
                    policy_doc = getattr(policy_data, 'policy_document', {})
                
                if isinstance(policy_doc, dict):
                    statements = policy_doc.get('Statement', [])
                    for statement in statements:
                        if isinstance(statement, dict):
                            actions = statement.get('Action', [])
                            resources = statement.get('Resource', [])
                            effect = statement.get('Effect', '')
                            
                            # Check for overly broad permissions
                            if effect == 'Allow':
                                if '*' in actions or '*' in resources:
                                    result = False
                                    break
                if not result:
                    break
    expected_value: null
    tags: ["security", "aws", "iam", "policies", "least_privilege"]
    severity: "high"
    category: "access_control"

  - id: 2020
    connection_id: 2
    name: "aws_iam_groups_used_for_permissions"
    description: "Verify that IAM groups are used to manage user permissions"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 71   # AC-2 (Account Management)
    control_name: "AC-2"
    field_path: "groups"
    resource_type: "AWSIAMResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if IAM groups exist and are being used
        if not isinstance(fetched_value, dict):
            result = False  # Fail if no groups
        else:
            result = len(fetched_value) > 0  # Pass if at least one group exists
    expected_value: null
    tags: ["security", "aws", "iam", "groups", "user_management"]
    severity: "medium"
    category: "access_control"

  - id: 2021
    connection_id: 2
    name: "aws_iam_users_in_groups"
    description: "Verify that IAM users are assigned to groups rather than having direct policies"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 71   # AC-2 (Account Management)
    control_name: "AC-2"
    field_path: "users"
    resource_type: "AWSIAMResource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if IAM users are assigned to groups
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no users
        else:
            result = True
            for user_name, user_data in fetched_value.items():
                groups = []
                inline_policies = []
                if isinstance(user_data, dict):
                    groups = user_data.get('groups', [])
                    inline_policies = user_data.get('inline_policies', [])
                else:
                    groups = getattr(user_data, 'groups', [])
                    inline_policies = getattr(user_data, 'inline_policies', [])
                
                # User should be in at least one group and have minimal direct policies
                if len(groups) == 0 and len(inline_policies) > 0:
                    result = False
                    break
    expected_value: null
    tags: ["security", "aws", "iam", "users", "group_membership"]
    severity: "medium"
    category: "access_control"

  # Additional EC2 Security Checks (2022-2025)
  - id: 2022
    connection_id: 2
    name: "aws_ec2_instances_no_public_ip"
    description: "Verify that EC2 instances do not have public IP addresses unless necessary"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 75   # AC-3 (Access Enforcement)
    control_name: "AC-3"
    field_path: "instances"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if EC2 instances have public IP addresses
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no instances
        else:
            result = True
            for instance_id, instance in fetched_value.items():
                public_ip = None
                if isinstance(instance, dict):
                    public_ip = instance.get('public_ip_address')
                else:
                    public_ip = getattr(instance, 'public_ip_address', None)
                
                # Fail if instance has a public IP (unless it's a bastion/jump host)
                if public_ip:
                    # This is a simplified check - in reality, you'd check instance purpose/tags
                    result = False
                    break
    expected_value: null
    tags: ["security", "aws", "ec2", "public_ip", "network_exposure"]
    severity: "medium"
    category: "access_control"

  - id: 2023
    connection_id: 2
    name: "aws_ec2_instances_latest_ami"
    description: "Verify that EC2 instances are using recent AMI versions"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 679  # SI-2 (Flaw Remediation)
    control_name: "SI-2"
    field_path: "instances"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if EC2 instances are using recent AMIs
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no instances
        else:
            result = True
            for instance_id, instance in fetched_value.items():
                image_id = None
                launch_time = None
                if isinstance(instance, dict):
                    image_id = instance.get('image_id')
                    launch_time = instance.get('launch_time')
                else:
                    image_id = getattr(instance, 'image_id', None)
                    launch_time = getattr(instance, 'launch_time', None)
                
                # This is a simplified check - in reality, you'd check AMI age and patch level
                # For now, just ensure image_id exists
                if not image_id:
                    result = False
                    break
    expected_value: null
    tags: ["security", "aws", "ec2", "ami", "patch_management"]
    severity: "medium"
    category: "system_information_integrity"

  - id: 2024
    connection_id: 2
    name: "aws_ec2_key_pairs_secured"
    description: "Verify that EC2 key pairs are properly managed and secured"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 157  # IA-2 (Identification and Authentication)
    control_name: "IA-2"
    field_path: "key_pairs"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if EC2 key pairs are properly managed
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no key pairs
        else:
            result = True
            for key_pair_name, key_pair in fetched_value.items():
                key_type = None
                if isinstance(key_pair, dict):
                    key_type = key_pair.get('key_type')
                else:
                    key_type = getattr(key_pair, 'key_type', None)
                
                # Prefer RSA keys over other types for security
                if key_type and key_type not in ['rsa', 'ed25519']:
                    result = False
                    break
    expected_value: null
    tags: ["security", "aws", "ec2", "key_pairs", "authentication"]
    severity: "medium"
    category: "identification_authentication"

  - id: 2025
    connection_id: 2
    name: "aws_elastic_ips_managed"
    description: "Verify that Elastic IPs are properly managed and not orphaned"
    framework_id: 2  # NIST 800-53
    framework_name: "NIST 800-53"
    control_id: 287  # CM-8 (System Component Inventory)
    control_name: "CM-8"
    field_path: "elastic_ips"
    resource_type: "AWSEC2Resource"
    operation:
      name: "custom"
      custom_logic: |
        # Check if Elastic IPs are associated with instances
        if not isinstance(fetched_value, dict):
            result = True  # Pass if no Elastic IPs
        else:
            result = True
            for eip_id, eip in fetched_value.items():
                instance_id = None
                if isinstance(eip, dict):
                    instance_id = eip.get('instance_id')
                else:
                    instance_id = getattr(eip, 'instance_id', None)
                
                # Fail if EIP is not associated with an instance (orphaned)
                if not instance_id:
                    result = False
                    break
    expected_value: null
    tags: ["security", "aws", "ec2", "elastic_ip", "resource_management"]
    severity: "low"
    category: "configuration_management" 